[{"title":"【转载】STM32串口ISP攻略","path":"/2024/07/25/094523/","content":"本文参考连接🔗https://rymcu.com/article/253如有侵权，可联系作者邮箱删除。子书承宇 1 STM32 串口 ISP 原理 STM32 单片机系统存储器中有一段 Bootloader 代码，他的主要作用为通过串口下载程序代码到单片机内部 Flash 中。该过程称为串口 ISP，也就是说串口与 Bootloader 进行通信，就可以实现代码下载功能了，下面详细讲解与 Bootloader 的通信规则。 2 Bootloader 通信规则 2.1 启动 bootloader 与 Bootloader 通信前，需要先启动他，也就是需要让单片机进入到 Bootloader 到代码中执行。通过 STM32 的两个引脚可以实现配置。如下图所示： image.png 如上图所示，可以配置成三种模式，第二种为启动 Bootloader 方式，即 BOOT\b0=1，BOOT1=0。 2.2 Bootloader 编码序列 image.png 当 STM32F10xx 系列单片机进入 Bootloader 程序后，单片机开始检测 PA10(串口 1 接收引脚)是否收到串口数据 0x7F，并且要求串口数据格式为 1bit 起始 +8bit 数据 +1bit 偶校验 +1bit 停止位。 收到 0x7F 后，单片机将内部串口的波特率设置和发送数据方相同，并且给主机回复应答信号 0x79。为方便描述，我们这里将发送数据方称为主机，STM32 单片机方称为从机。回复完应答信号 0x79 后，表示从机已经准备好接收主机的指令了。 2.3 波特率选择 为保证数据传输的正确性，一般选择在 1200bps 至 115200bps 之间。 2.4 Bootloader 指令集 完整指令集如下图，但并不是单片机同时支持所有的指令，后续将逐一介绍。 2.4.1 Get 命令 该指令允许主机获取从机的 Bootloader 版本号以及支持哪些命令。当从机收到主机发来的 Get 命令后，从机将 Bootloader 版本及所支持的命令发送给主机。发送 Get 命令的主机端时序如下图所示。 image.png 代码实现如下： char GetCMD(DeviceInfo_t *DInfo) { char error,len; //step1 发送指令0x00,0xFF,并等待ACK SendByte(0x00); SendByte(0xFF); error = ACK();if(!error) return 0; //step2 接收数据 len = GetByte(); DInfo-&gt;cmd_count = len;//第一个字节为命令数量N DInfo-&gt;bootloaderversion = GetByte();//第二个字节为版本号 for(int i =0;i&lt;len;i++) DInfo-&gt;cmd[i] = GetByte();//获取CMD error = ACK();if(!error) return 0; //step3 处理数据，并打印版本号，命令等 //打印数据，并清空串口缓存 return 1; } ​ 2.4.2 Get ID 命令 该命令用于获取单片机的的产品 ID，主机端时序如下图所示。 image.png 代码实现如下： char GetID(DeviceInfo_t *DInfo) { char len,error; //step1 发送序列0x02,0xfd，并等待ACK SendByte(0x02); SendByte(0xFD); error = ACK();if(!error) return 0; //step2 接收PID，并等待ACK len = GetByte();//第一个字节为ID长度N-1 for(int i =0;i&lt;=len;i++) DInfo-&gt;PID[i] = GetByte();//获取ID error = ACK();if(!error) return 0; return 1; //step3 清空接收缓存，并打印PID } ​ 2.4.3 Read Memory 命令 读内存命令用来读取从机单片机内部 RAM，FLASH，信息块（包括系统存储区和选项字节）中的数据。主机端时序如下所示。 image.png 代码实现如下： ///////////////////////////////////////////////// // //读取数据 //与写数据步骤类似 //addr必须能被4整除，len发送数据长度-1，单次不能超过256B ///////////////////////////////////////////////// char ReadMem(unsigned char *data, unsigned int addr, unsigned char len) { unsigned char temp[4],error; //保存addr的四个字节 int i; temp[0] = ((addr&gt;&gt;24) &amp; 0xFF); temp[1] = ((addr&gt;&gt;16) &amp; 0xFF); temp[2] = ((addr&gt;&gt; 8) &amp; 0xFF); temp[3] = ((addr ) &amp; 0xFF); //step1 发送序列0x11,0xEE，并等待ACK SendByte(0x11); SendByte(0xEE); error = ACK();if(!error) return 0; //step2 发送地址，先发高字节 SendByte(temp[0]); SendByte(temp[1]); SendByte(temp[2]); SendByte(temp[3]); //step3 发送地址校验，并等待ACK SendByte(CheckSum(temp, 4)); error = ACK();if(!error) return 0; //step4，发送len及校验，并等待ACK SendByte(len); SendByte(~len); error = ACK();if(!error) return 0; //step4 接收长度为len+1的数据 for(i=0;i&lt;=len;i++) data[i] = GetByte(); return 1; } ​ 2.4.4 Write Memory 命令 写内存命令用来往从机单片机内部 RAM，FLASH，信息块（包括系统存储区和选项字节）中写入数据，主机端时序如下所示。 image.png 往选择字区写入数据时，开始地址必须为 0x1FFFF800。 代码实现如下： ///////////////////////////////////////////////// // //写入数据块，从*data处，往stm32的addr处，写入len+1字节数据 // ///////////////////////////////////////////////// char WriteMem(unsigned char *data, unsigned int addr, unsigned char len) { unsigned char temp[4],error; //保存addr的四个字节 int i; temp[0] = ((addr&gt;&gt;24) &amp; 0xFF); temp[1] = ((addr&gt;&gt;16) &amp; 0xFF); temp[2] = ((addr&gt;&gt;8 ) &amp; 0xFF); temp[3] = ((addr ) &amp; 0xFF); //step1 发送序列0x31,0xCE,并等待ACK SendByte(0x31); SendByte(0xCE); error = ACK();if(!error) return 0; //step2 发送地址，先发高字节 SendByte(temp[0]); SendByte(temp[1]); SendByte(temp[2]); SendByte(temp[3]); //step3 发送地址校验，并等待ACK SendByte(CheckSum(temp, 4)); error = ACK();if(!error) return 0; //step4 发送len SendByte(len); //step5 连续发送数据，最后字节为校验，并等待ACK for(i=0;i&lt;=len;i++) &#123; SendByte(data[i]); &#125; SendByte(len ^ CheckSum(data, len+1)); //delay_msec(3000); error = ACK();if(!error) return 0; //清空串口缓存，并延时1s. return 1; } ​ 2.4.5 Erase Memory 命令 擦除从机单片机内部 FLASH 命令，仅单片机 Bootloader 版本 3.0 以下支持该命令。主机端时序如下所示。 image.png 全片擦除代码实现如下： ///////////////////////////////////////////////// // //全片擦除,bootloader V3.0以下有效 // step1 发送序列0x43,0xbc,并等待ACK // step2 发送序列0xff,0x00,并等待ACK // step3 清空串口接收缓冲 ///////////////////////////////////////////////// char EraseAll() { char error; SendByte(0x43);// SendByte(0xBC); error = ACK();if(!error) return 0; SendByte(0xFF); SendByte(0x00); //不同的产品，全片擦除的时间长短不一，500ms的时间不一定够， //因此不能用现成的ACK函数，需重写如下： //error = ACK();if(!error) return 0; while(!MyComRevBUff.size()) { delay_msec(1);//出让线程 } if(0x79 == GetByte()) return 1; else return 0; } ​ 2.4.6 Extended Erase Memory 命令 仅单片机 Bootloader 版本 3.0 及以上支持该命令。主机端时序如下所示，以 Erase Memory 命令相比，该命令为双字节命令，即 Erase cmd 为双字节，例如 0xFFFF。 image.png 全片擦除代码实现如下： ///////////////////////////////////////////////// // //全片擦除,bootloader V3.0及以上有效 // step1 发送序列0x43,0xbc,并等待ACK // step2 发送序列0xff,0x00,并等待ACK // step3 清空串口接收缓冲 ///////////////////////////////////////////////// char ExtendedEraseAll() { char error; SendByte(0x44);// SendByte(0xBB); error = ACK();if(!error) return 0; unsigned char EraseCMD[2]; EraseCMD[0] = 0xFF; EraseCMD[1] = 0xFF; SendByte(0xFF);//写入地址0xFFFF SendByte(0xFF); SendByte(CheckSum(EraseCMD, 2));//双字节校验 //不同的产品，全片擦除的时间长短不一，500ms的时间不一定够， //因此不能用现成的ACK函数，需重写如下： //error = ACK();if(!error) return 0; while(!MyComRevBUff.size()) &#123; delay_msec(1);//出让线程 &#125; if(0x79 == GetByte()) return 1; else return 0; } ​ 2.4.7 GO 命令 跳转到从机的指定地址开始执行程序。G0 命令主机时序如下。 image.png 代码实现如下： ///////////////////////////////////////////////// // //跳转执行指令,下载完成后，跳转到RAM或内部FLASH执行 // // ///////////////////////////////////////////////// char CMDGo(unsigned int addr) { unsigned char temp[4],error; //保存addr的四个字节 int i; temp[0] = ((addr&gt;&gt;24) &amp; 0xFF); temp[1] = ((addr&gt;&gt;16) &amp; 0xFF); temp[2] = ((addr&gt;&gt;8 ) &amp; 0xFF); temp[3] = ((addr ) &amp; 0xFF); //step1 发送序列0x21,0xDE,并等待ACK SendByte(0x21); SendByte(0xDE); error = ACK();if(!error) return 0; //step2 发送地址，先发高字节 SendByte(temp[0]); SendByte(temp[1]); SendByte(temp[2]); SendByte(temp[3]); //step3 发送地址校验，并等待ACK SendByte(CheckSum(temp, 4)); error = ACK();if(!error) return 0; return 1; } ​ 3 STM32 串口 ISP 操作参考步骤 step1 主机发送 0x7F，启动从机并等待接收主机命令； step2 主机发送 Get 命令，获取从机 Bootloader 版本号及所支持的命令等； step3 主机发送 Get ID 命令，获取从机产品 ID； step4 主机发送擦除命令，擦除从机内部 FLASH，为写数据做准备； step5 主机发送 Write Memory 命令，将代码写入从机器； step6 主机发送 Read Memory 命令，读取从机代码并与写入的数据进行对比校验； step7 主机发送 Go 命令，从机跳转至程序开始处执行代码，观察现象是否与程序一致。 step8 结束。 转载本文，记录需要的知识，方便查阅。子书承宇","tags":["STM32","ISP"],"categories":["理论"]},{"title":"机器之眼的视神经--卷积算法","path":"/2024/07/14/220529/","content":"大学时候，随着学习到的东西越来越多，偶然一次接触到了机器视觉，于是大三和大四基本都在做与机器视觉有关的东西，毕业设计也是依靠谷歌出品的MediaPipe，主要是在于使用MediaPipe进行姿势检测，这篇文章并不是讲解如何做，而是将机器视觉中的算法进行简单的介绍。子书承宇 卷积神经网络算法的原理 卷积计算和卷积核 先说一个词，卷积核也是在卷积神经网络中必不可少的，卷积核简单理解就是一种特征。我们的大脑在看到一个物体时，是如何知道他是什么的，就是通过一个一个部位的特征组合形成一个完整的图像信息，我们就能判断他是什么。这里的卷积神经网络就是在模仿人类视觉。先看一张图。 卷积核 这四张分别表示了四种特征 卷积，这在信号与系统（或者是通信原理，有点记不清了）中有学习到，只不过当初学习的时候是通信中译码和解码时候提到的，没有涉及到机器视觉。接下来讲解一下如何通过卷积计算提取特征矩阵。 如下图，按照下图方法，将矩阵逐一提取出来与卷积核卷积得出右侧绿色方块中的数值，就像这样 卷积神经网络算法 这是结果，数值越高代表这种特征越明显。这里输出的5*5矩阵就是卷积层的面积，而另一个参数厚度指的是有 N 个卷积核对原图进行卷积操作，输出的就是 N 个特征矩阵。 卷积神经网络算法 池化 目的主要是降低数据维度，减少计算量。池化有很多种，这里展示的是最简单的一种，下池化中的最大池化：MaxPool。在本文案例只是一个演示，在实际的图像处理中，数据比这里复杂的多，不仅要考虑图像整体大小，还包括颜色信息，明暗度信息等。 最大池化 展平与接入连接层、激活 展平操作本质上是一个简单的重排元素的过程，使得原始的多维数据结构能够被后续处理层（如全连接层）接受和处理。例如展成一列，就像神经网络中的全连接层接收的输入。 这里引用一张图，连接层相当于多个线性变换，也就是图中的隐层 接入连接层 为什么要激活 如果不用激活函数，每一层输出都是上层输入的线性函数，无论神经网络有多少层，输出都是输入的线性组合，这种情况就是最原始的感知机（Perceptron）。使用激活函数能够给神经元引入非线性因素，使得神经网络可以任意逼近任何非线性函数，使深层神经网络表达能力更加强大，这样神经网络就可以应用到众多的非线性模型中。–深度学习中常见的10种激活函数（Activation Function）总结 这篇文章讲到了十种激活函数深度学习中常见的10种激活函数（Activation Function）总结。 常用的激活函数如sigmoid，如果要对概率建模，此函数作为输出非常有用。神经网络经过大量计算输出的结果更可能数值域的范围非常大，这时候就用到激活函数限定输出范围，限定到我们能够处理的范围或者想要处理的范围 线性和非线性.jpeg 1 分类后机器便知道这张图几成概率是物体 1，几成概率是物体 2。 整个过程相当于从输入分类，神经网络判断这些数据是否具有卷积核的特征值，有理想输出为 1，没有理想输出为 0。 以上的过程是单层最简单的基于卷积神经网络的机器视觉过程，其实还有许多的步骤在上文中未提及，有些步骤和算法用于加强识别能力或者是降低数据信息等等。卷积神经网络的机器视觉用于图像分类、目标检测、人脸识别和图像生成等任务，这样的技术在十年前就已经出来了，当下使用的更新的算法，并且不止在图像领域，在其他如机器学习，自然语言处理 (NLP)等等。本文可能有部分描述不准确或者与实际算法有偏差或错误，欢迎指正。子书承宇 参考文献与博客： 深度学习中常见的10种激活函数（Activation Function）总结 卷积神经网络（CNN）自学笔记2：卷积层 CNN 理解神经网络中卷积(大小，通道数，深度) 【学习笔记】Pytorch深度学习-网络层之池化层、线性层、激活函数层 【学习笔记】计算机视觉与深度学习(2.全连接神经网络) 神经网络算法 - 一文搞懂FFNN（前馈神经网络）","tags":["卷积","机器视觉"],"categories":["理论"]},{"title":"kindle 越狱+插件安装","path":"/2024/07/10/143551/","content":"Kindle已经退出中国市场，有点惋惜，国内账号无法通过自动推送邮箱发送到设备了，之前有翻过一些教程，但是没有越狱成功，今天试了下成功越狱于是有了这篇文章，网上的教程已经很详细了，这里我就不再赘述，分享些教程和网站。子书承宇 准备 Kindle越狱 链接：Kindle越狱支持一览：检查 Kindle设备能否越狱 我的是kindle8这是教程链接，使用的教程是Kindle 通用越狱教程：适用版本小于等于 5.16.2.1.1 固件 注意这一步，速度要快 依次点击【销售设备→销售】按钮，稍等片刻等待“Kindle按钮示意图”出现；一旦屏幕出现“Kindle按钮示意图”，立即用USB数据线将Kindle连到电脑； 基本上一次成功。 越狱插件 Kindle越狱插件：Kindle越狱插件资源下载及详细安装步骤 需要先按照教程安装MobileRead Package Installer (MRPI) — 插件安装器和KUAL — 插件程序启动器 我在安装USBNetwork Hack插件时遇到无法通过ssh访问设备的问题，我同时还参考了Installing USBNetwork (SSH service) on Kindle中SSH via USB节提到需要在搜索栏输入;un才能打开ssh服务。 安装完之后不得不说上传下载文件真是舒服多了，不用每次通过usb连接。 另外 python 插件应该是有pip的，可以去python目录下，原本的python库是不带socker的，去Python二进制文件目录下调用pip安装socker即可。后面可以使用pip安装其他库，运行自动化程序。 通过网上的使用美国亚马逊账号设置设备可以像之前那样推送书籍。一顿操作之后把之前在 documents 的文件都清空了，后悔没有提前备份，有一些用于操作插件的文件也清空了。但是越狱效果还是在，能通过ssh连接设备。重新安装一次KUAL — 插件程序启动器就可以正常使用了。并且多出来的异常文本书籍可以删除，删除后到目前为止没遇到异常。子书承宇","tags":["kindle"],"categories":["折腾"]},{"title":"Image转RGB565工具","path":"/2024/07/09/115544/","content":"写在前面 一个小工具 /* 样式用于将标签样式化为按钮 */ .custom-button { display: inline-block; padding: 10px 20px; font-size: 16px; font-weight: bold; color: #fff; background-color: #007bff; border: none; border-radius: 5px; cursor: pointer; } /* 隐藏文件选择输入框 */ .input-file { display: none; } // Dither threshold values for each color channel const ditherThresholdR = [ 0, 8, 2, 10, 12, 4, 14, 6, 3, 11, 1, 9, 15, 7, 13, 5 ]; const ditherThresholdG = [ 0, 8, 2, 10, 12, 4, 14, 6, 3, 11, 1, 9, 15, 7, 13, 5 ]; const ditherThresholdB = [ 0, 8, 2, 10, 12, 4, 14, 6, 3, 11, 1, 9, 15, 7, 13, 5 ]; // Returns the nearest color value function getClosestColorValue(colorValue) { return (colorValue >> 2 < 2); } /** * 对图像数据应用抖动算法 * * @param {Uint8ClampedArray} imageData - 包含图像数据的数组，每个像素为 RGBA 格式 * @param {number} width - 图像的宽度 * @param {number} height - 图像的高度 * @return {Uint8ClampedArray} - 处理后的图像数据数组 */ function dither(imageData, width, height) { for (let y = 0; y < height; y++) { for (let x = 0; x < width; x++) { const pixelIndex = (y * width + x) * 4; let r = imageData[pixelIndex]; let g = imageData[pixelIndex + 1]; let b = imageData[pixelIndex + 2]; // 获取此像素的抖动阈值索引 const thresholdIndex = ((y & 3) < 2) + (x & 3); // 将抖动算法应用于每个颜色通道 r = getClosestColorValue(Math.min(r + ditherThresholdR[thresholdIndex], 255)); g = getClosestColorValue(Math.min(g + ditherThresholdG[thresholdIndex], 255)); b = getClosestColorValue(Math.min(b + ditherThresholdB[thresholdIndex], 255)); // 更新 imageData 数组中的像素数据 imageData[pixelIndex] = r; imageData[pixelIndex + 1] = g; imageData[pixelIndex + 2] = b; } } return imageData; } function handleFileSelect_dither(event) { console.log(\"handleFileSelect_dither\"); var file = event.target.files[0]; if (!file) { alert('Please select an image file.'); return; } var reader = new FileReader(); reader.onload = function (event) { var img = new Image(); img.onload = function () { var canvas = document.createElement('canvas'); var ctx = canvas.getContext('2d'); canvas.width = img.width; canvas.height = img.height; ctx.drawImage(img, 0, 0); var imageData = ctx.getImageData(0, 0, img.width, img.height); var data = imageData.data; data_B = dither(data, img.width,img.height); var rgb565Array = []; for (var i = 0; i < data_B.length; i += 4) { var r = data_B[i]; var g = data_B[i + 1]; var b = data_B[i + 2]; // Convert RGB888 to RGB565 var r5 = (r >> 3) & 0x1F; var g6 = (g >> 2) & 0x3F; var b5 = (b >> 3) & 0x1F; var rgb565 = (r5 < 11) | (g6 < 5) | b5; rgb565Array.push(rgb565); } var width = img.width; var height = img.height; // var rgb565Array_B = []; // Generate C array output var cArray = 'const uint16_t image[' + height + '][' + width + '] = { '; for (var row = 0; row < height; row++) { cArray += ' {'; for (var col = 0; col < width; col++) { var index = row * width + col; cArray += '0x' + rgb565Array[index].toString(16); if (col < width - 1) { cArray += ', '; } } cArray += '}'; if (row < height - 1) { cArray += ', '; } else { cArray += ' '; } } cArray += '};'; // Save to text file var blob = new Blob([cArray], { type: 'text/plain' }); var url = URL.createObjectURL(blob); var a = document.createElement('a'); a.href = url; a.download = 'image_data.c'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); }; img.src = event.target.result; }; reader.readAsDataURL(file); } function handleFileSelect_no_dither(event) { console.log(\"handleFileSelect_no_dither\"); var file = event.target.files[0]; if (!file) { alert('Please select an image file.'); return; } var reader = new FileReader(); reader.onload = function (event) { var img = new Image(); img.onload = function () { var canvas = document.createElement('canvas'); var ctx = canvas.getContext('2d'); canvas.width = img.width; canvas.height = img.height; ctx.drawImage(img, 0, 0); var imageData = ctx.getImageData(0, 0, img.width, img.height); var data = imageData.data; data_B = data; var rgb565Array = []; for (var i = 0; i < data_B.length; i += 4) { var r = data_B[i]; var g = data_B[i + 1]; var b = data_B[i + 2]; // Convert RGB888 to RGB565 var r5 = (r >> 3) & 0x1F; var g6 = (g >> 2) & 0x3F; var b5 = (b >> 3) & 0x1F; var rgb565 = (r5 < 11) | (g6 < 5) | b5; rgb565Array.push(rgb565); } var width = img.width; var height = img.height; // var rgb565Array_B = []; // Generate C array output var cArray = 'const uint16_t image[' + height + '][' + width + '] = { '; for (var row = 0; row < height; row++) { cArray += ' {'; for (var col = 0; col < width; col++) { var index = row * width + col; cArray += '0x' + rgb565Array[index].toString(16); if (col < width - 1) { cArray += ', '; } } cArray += '}'; if (row < height - 1) { cArray += ', '; } else { cArray += ' '; } } cArray += '};'; // Save to text file var blob = new Blob([cArray], { type: 'text/plain' }); var url = URL.createObjectURL(blob); var a = document.createElement('a'); a.href = url; a.download = 'image_data.c'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); }; img.src = event.target.result; }; reader.readAsDataURL(file); }","tags":["RGB565"],"categories":["工具"]},{"title":"用STM32和ESP8266做一个PC机副屏(纯娱乐)","path":"/2024/07/01/184130/","content":"前段时间自己做了一套M910X的亚克力外壳，设计之初考虑到侧面能够添加自己的副屏，再加上曾做过点阵RGB，于是也设置了防止RGB点阵的位置。最初的想法是在这个设备上显示视频，但是刷新率太低了，没有做到 24fps ，放弃了显示视频，转而用了一个简单的PC机副屏，显示一些电脑性能信息，比如CPU频率，内存使用情况，硬盘使用情况，网络情况等等。另外这个副屏外面还做了一圈 RGB。这个副屏由这几个部分组成，四块 SPI ST7735 屏幕（160*128*4）和一圈ws2812b 灯珠组成，主控是 STM32F103C8T6 和 ESP8266组成。stm32 主要作用是控制屏幕刷新和点亮 RGB ，esp8266 主要作用是通过串口发送 json 数据，让 STM32 解析显示。子书承宇 这个副屏由这几个部分组成，四块 SPI ST7735 屏幕（160*128*4）和一圈ws2812b 灯珠组成，主控是 STM32F103C8T6 和 ESP8266组成。stm32 主要作用是控制屏幕刷新和点亮 RGB ，esp8266 主要作用是通过串口发送 json 数据，让 STM32 解析显示。 飞线 亚克力外壳亚克力外壳 下面是副屏 副屏 副屏UI 硬件部分 SPI ST7735这部分硬件设计，四块屏幕共用一组SPI，通过不同的CS来控制不同的屏幕显示。原本有做背光控制，但是买回来的屏幕上电后背光默认开启，有面有空再研究研究啥情况。 12 layout 11 3D 图 3D_左侧USB3.0拓展卡 关于背光控制电路 背光控制需要使用pwm调光，买回来的屏幕问了客服说不支持调光，我看了下lcd的板子，上面的背光电路被强行打开了，所以调不了。重新返工屏上线路后如下图，左侧是修改前，右侧是修改后 + 板上电路。将R148与3V3断开，BLK引脚连接主板控制引脚。当BL_CTRL_PWM为低电平时 UGS&lt;0U_{GS}&lt;0UGS​&lt;0 ，有压差导通，BLK信号高电平。裸屏背光信号BL与GND导通，有电流流过，背光亮，反之背光暗。 pwm调背光 软件部分 时序设计 第一次做时序打算使用GPIO外部中断，但实际测试，想用GPIO外部中断，发现中断触发时序概率性错乱导致卡死，所以换成了串口中断。 这是条失败的路 时序框图这个时序框图不是完整的，有些细节部分没有写出来，但是大致思路是这样时序框图这是实际时序时序 调试过程过程中遇到些许问题，有时候调得头皮发麻，一整天愣是解不出来下图是第一次进入中断时也就是发送字符长度的时候Debug1放大之后是这样的Debug1放大中断进入debug ，奇怪的是我的代码中串口发送是写在进入STM32 触发中断（GPIO6 边沿触发）后的esp8266片段代码截图 1实际效果不影响 STM32 串口接收数据。这是实际效果STM32 串口接收数据实际效果 1 下面讲成功的时序 时序总图 时序总图 时序大概是这样： 8266：上电初始化-&gt;连接WiFi-&gt;主循环侦测UDP连接 STM32： 上电初始化-&gt;打开串口中断-&gt;进入主循环显示 调试过程 上电瞬间及初始化 此处解决8266上电过程中串口有段杂波干扰STM32串口接收 上电瞬间ESP8266串口会有一小段杂波，最初做GPIO外部中断就是为了避免这部分，但是最终想了很多办法没有解决。如下图D1通道，前面一小段就是杂波。右边的两小段下拉是连接Wi-Fi时发送的数据.。 上电瞬间时序总图 这里是初始化HAL库函数和四块屏幕后，进入while循环前的代码，可以看到右侧2处D1和D0通道就是串口中断产生的结果，由于一次直接收一个字符，所以把异常数据都挤掉了。猜测1处可能是拉高后打开了 串口中断，进入中断后又被拉低了。 上电初始化时序 代码截图1 下面是中断放大后的时序图以及对应的代码，高电平一直触发单个字节接收中断。 时序代码截图_1 1234567891011121314151617/* 高电平 接收数据 */if (pin_pb6_value == 1) &#123;\t/* 回复8266，GPIO拉底 解锁 已经完成第一字节串口接收 */\tHAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, GPIO_PIN_RESET);\t/* 串口 1debug */\tHAL_UART_Transmit(&amp;huart1, &amp;USART_RX_LINE, atoi(USART_RX_ONE_LINE) + 1, 100);\tCS++;\tif(CS&gt;4)&#123; CS = 1;\t&#125;\t/* 串口中断开启接收长度 1 */\tHAL_UART_Receive_IT(&amp;huart2, &amp;USART_RX_ONE_LINE_LEN, 1);&#125; 串口中断部分 这是串口中断部分时序 串口中断放大图 串口中断代码片段12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/**************************************************************************** * 函数名: HAL_UART_RxCpltCallback() * 功 能: 串口中断函数 * 输 入: None * 全局变量 ALL * 输 出: 无 */void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) &#123;\tif (huart-&gt;Instance == USART2) // ???????????? USART1\t&#123; /* 串口 1debug */ HAL_UART_Transmit(&amp;huart1, &quot;IN UART_RxCpltCallback &quot;, 23, 100); /*判断 PB6 为上升或下降沿触发*/ pin_pb6_value = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_6); /* 高电平 接收数据 */ if (pin_pb6_value == 1) &#123; /* 回复8266，GPIO拉底 解锁 已经完成第一字节串口接收 */ HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, GPIO_PIN_RESET); /* 串口 1debug */ HAL_UART_Transmit(&amp;huart1, &amp;USART_RX_LINE, atoi(USART_RX_ONE_LINE) + 1, 100); CS++; if (CS &gt; 4) &#123; CS = 1; &#125; /* 串口中断开启接收长度 1 */ HAL_UART_Receive_IT(&amp;huart2, &amp;USART_RX_ONE_LINE_LEN, 1); &#125; /* 低电平 接收长度 */ if (pin_pb6_value == 0) &#123; /* 串口 1debug */ HAL_UART_Transmit(&amp;huart1, &quot;pin_pb6_value == 0 &quot;, 19, 100); /* 回复8266，GPIO拉底 解锁 已经完成第一字节串口接收 */ HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, GPIO_PIN_RESET); /* 串口 1debug */ HAL_UART_Transmit(&amp;huart1, &quot;GPIO7 DOWN &quot;, 11, 100); /* 串口 2 接收长度2 */ HAL_UART_Receive(&amp;huart2, &amp;USART_RX_ONE_LINE, atoi(USART_RX_ONE_LINE_LEN) + 2, 0xFFFF); /* 回复8266，GPIO拉高 已经完成第二字节串口接收 */ HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, GPIO_PIN_SET); /* 串口 1debug */ HAL_UART_Transmit(&amp;huart1, &quot;GPIO7 UP &quot;, 9, 100); /* 串口 1debug */ HAL_UART_Transmit(&amp;huart1, &quot; ############################ &quot;, 30, 100); /* 串口 1debug */ HAL_UART_Transmit(&amp;huart1, &amp;USART_RX_ONE_LINE_LEN, 1, 100); /* 串口 1debug */ HAL_UART_Transmit(&amp;huart1, &quot; ############################ &quot;, 30, 100); /* 串口 1debug */ HAL_UART_Transmit(&amp;huart1, &amp;USART_RX_ONE_LINE, atoi(USART_RX_ONE_LINE_LEN) + 2, 100); /* 串口 1debug */ HAL_UART_Transmit(&amp;huart1, &quot; ############################ &quot;, 30, 100); /* 开启下一次接收数据内容中断 */ HAL_UART_Receive_IT(&amp;huart2, &amp;USART_RX_LINE, atoi(USART_RX_ONE_LINE) + 2); &#125;\t&#125;&#125; 下面是三个串口数据发送过程 第一步 获取数据长度的长度 预发送长度为1045长度的字符串，1045的长度为4，这里指的就是4 ESP8266 拉低 GPIO6 做准备，接着ESP8266发送串口数据触发STM32串口中断。 串口中断放大图1 第二步： 获取数据的长度 上一步完成接收进入中断，STM32拉高GPIO7，进入阻塞串口接收，此时ESP8266（串口中断放大图2）ESP8266等待100ms后发送数据长度，STM32接收完成拉高GPIO7，ESP8266退出死循环进入下一步发送数据内容。STM32退出中断前打开串口中断，准备接收数据。 串口中断放大图2 对ESP8266应代码如下，等待GPIO7被拉高。 123456789101112// 打印长度 尾部带有\\rSerial.print(static_cast&lt;int&gt;(strlen(substring)));delay(100);// 打印长度Serial.println(Tcp_len);// 等待STM32响应，调试需注释while (!digitalRead(4)) &#123; //等待响应 delay(80);&#125; 第三步： 获取数据内容 上一步GPIO7被拉高后，ESP8266发送数据内容，STM32进入串口中断，识别到GPIO7为高，拉低GPIO7，打开串口中断，STM32准备接收下一次数据长度的长度。 串口中断放大图3 时序设计部分到这里就结束了。 UI UI部分是直接使用st7735驱动中自带的，简单做了下，自己做的部分主要是换字体，换成了霞鹜文楷等宽。这部分我没有去看具体显示文本的流程，暂时阶段是能用就行。 关于图像显示，我在Image转RGB565工具放了两个摁钮，可以将RGB图像转成RGB565的字符串，目前颜色部分好像还是有点问题（原本蓝色在屏上会显示出绿色），但是基本形状是正确的。 Image转RGB565工具https://hp-l.github.io/2024/07/09/115544/ 还没写完…","tags":["ESP8266","STM32","HAL"],"categories":["作品"]},{"title":"ADC上是否要加旁路电容","path":"/2024/05/08/054333/","content":"之所以写这篇博客，是调试能源卡程序的时候发现ADC的数值总是高了那么一点，而且如果循环检测时，两次检测读取的时间必须大于1000ms，否则会出现读取数据无变化的情况。但是用示波器或者万用表点ADC这条线，不需要延时1000ms也能够快速响应进行ADC检测了。上网查阅了相关信息初步得出一个结论：ADC硬件线路最好加上旁路电容，否则会出现上述情况。子书承宇 参考 电池电压检测在ADC引脚采样，使用旁路电容可以降低噪声。实际测量中发现，为添加时，电压略微偏高，添加电容后电压稳定。 电容（2）旁路电容工作原理深度解析https://www.cnblogs.com/sunshine-jackie/p/8324709.html 【STM32学习】ADC（一）—— STM32 内置 AD 模块框图https://blog.csdn.net/challenglistic/article/details/132311833 添加旁路电容的原因 高低电平变换时间越短，则产生的谐波（高频）成分越丰富，因此，低速开关并不意味着高频成分少，信号频率为1MHz方波存在的高频谐波成分比同频率正弦波要高得多，因为方波的高低电平切换时间非常短，而正弦波则相对非常缓慢。【电容（2）旁路电容工作原理深度解析】 adc 简单来说，STM32（其他MCU应该也是类似的）ADC通过开关打开，连接之后就可以通过运放检测电压了，这是开关打开与关闭就像上面所说，低速开关并不意味着高频成分少，自然会产生高频噪声，这是旁路电容就起到了除噪声的作用，参考链接中说到，IC中存在大量运放，所有的VDD全部同源时，这样的高频信号叠加起来便会产生杂乱的噪声，影响VDD原本干净的电压。 也就是说，其它门的噪声电压（也称为共路噪声）被传递到门A的输出端，同一时间逻辑切换越多则产生的共路噪声越大，一旦叠加在VDD上的共路噪声超过芯片的噪声容限，电路因无法有效地判断高低电平而导致异常【电容（2）旁路电容工作原理深度解析】","tags":["ADC"],"categories":["应用"]},{"title":"制作一个自动远程更新的RGB万年历","path":"/2024/05/04/152534/","content":"今年一月份整理元件箱的时候发现了一个8位RGB灯条，想起网上前段时间流行的 WIFI 像素时钟：LaMetric子书承宇 正好可以巩固一下曾经写代码的快乐时光，开搞！！手上的灯珠比较大，当时也没有仔细考虑工业设计，就打算做个能用的就行。 下面做了个简单的第一版，其实真的可以优化很多地方，看完不要笑😂😂😂，但是懒得搞了，先用着再说 硬件创造世界，软件让世界更美好，硬件底层搭好了，软件能实现出各种各样的功能，优化人类体验。 调试的时候拍的 硬件设计 硬件设计其实比较简单，我懒到电源直接买了整个模块搭上去。。。就是PCB正面左边二维码区域，PCB正面右边就是8266模块了，背面的是陀螺仪的降压IC PCB正面 PCB背面 原理图 硬件预留了18650电池和电量检测部分电路，软件没有还没有做 原理图1 这个小项目 RGB 灯有 100 个，也就是10 * 10 = 100的点阵，当时没想那么多，结果就是很多图像没有办法展示出来了，LaMetric可是 4 * 8 * 8 = 256像素的，按照设计第一版有预留电容，但是背面的图案太不好看了，就直接拿掉了（按道理加电容更加稳定），一百个灯珠，焊接是真的累😮‍💨 原理图2 功耗测试 实际测试发现，运行彩虹流水灯，也就是功耗拉满的时候过 RGB 灯珠电流达到了 0.9A 左右，也就是5V*09.A=4.5W了，功耗比较高了，再测了测发热量满载都50°C了 温度 软件设计 代码是arduino写的，写了两千多行，代码长了点，不太好展示，基本逻辑就是控制RGB显示图案出来。 下面展示几个联网跟新的操作 联网抓取json文件 每天检测两次，看是否有固件更新，一但有就马上判断进入OTA了 获取更新 文件格式如下： 1234567&#123; &quot;app_version_X&quot;: 0, //主版本号 &quot;app_version_Y&quot;: 0, //子版本号 &quot;app_version_Z&quot;: 5, //阶段版本号 &quot;update&quot;: 1, //更新锁 &quot;MUST_update&quot;: 0 //强制更新&#125; 通过http网址跟新固件 就这个功能函数我找了好久，网上大部分都是 arduino IDE 更新固件，要不就是局域网跟新，自己整合了一段时间，打包了一个函数，直接拿去使用，记得需要添加头文件 下面这段是更新固件的百分数，实现每增加1%就亮一个灯。 1strip.setPixelColor(((progress / (total / 100))) - 1, (progress / (total / 100)) / 100 * 255 * brightness / 100, (255 - (progress / (total / 100)) / 100 * 255) * brightness / 100, (255 - (progress / (total / 100)) / 100 * 255) * brightness / 100); 而http://V1_0_1_beta.bin可以替换成自己的固件链接 完整函数如下： 123456789101112131415161718192021222324252627282930313233343536373839404142//必备的头文件#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266httpUpdate.h&gt;/** * 功能：联网下载固件文件OTA * @param NONE * @return NONE * @example https_OTA(); * @note NONE * @link https://zhuanlan.zhihu.com/p/435855807 * @history * V0.0.1 2024-01-05 初始版本，未能实现功能 * V0.0.1 2024-01-08 更新变量 UpdateClient，成功升级 * */void https_OTA() &#123; RGB_GFX_PIC(up_date); while (1) &#123; // 设置回调函数以获取下载进度 ESPhttpUpdate.onProgress([](int progress, int total) &#123; //注释打印 Serial.printf(&quot;Progress: %d%% &quot;, (progress * 100) / total); strip.setPixelColor(((progress / (total / 100))) - 1, (progress / (total / 100)) / 100 * 255 * brightness / 100, (255 - (progress / (total / 100)) / 100 * 255) * brightness / 100, (255 - (progress / (total / 100)) / 100 * 255) * brightness / 100); strip.show(); &#125;); t_httpUpdate_return ret = ESPhttpUpdate.update(UpdateClient, &quot;http://V1_0_1_beta.bin&quot;); switch (ret) &#123; case HTTP_UPDATE_OK: //注释打印 Serial.println(&quot;Firmware updated successfully&quot;); break; case HTTP_UPDATE_FAILED: //注释打印 Serial.println(&quot;Firmware update failed&quot;); break; case HTTP_UPDATE_NO_UPDATES: //注释打印 Serial.println(&quot;No firmware updates available&quot;); break; default: //注释打印 Serial.printf(&quot;Firmware update error %d &quot;, ret); break; &#125; &#125;&#125; 除了网络信号不好之外，没有出过一次差错，这个小玩意就这样放在那里稳定地运行着。这个版本后续没有再做了，算是一次尝试，毕业后第一次捡回了嵌入式编程，回顾下大学那会敲代码的快乐时光。才几个月没有动，基本上是重新学了，这老本行不能就这样丢了呀，以后再多做些好玩的项目练练手。子书承宇","tags":["机器之脉络","ws2812b","esp8266"],"categories":["作品"]},{"title":"蒸汽核心能源卡诞生日","path":"/2024/04/27/233524/","content":"最近想做一块移动充电板子，想着以后其他小制作能用得上，起个名字就叫“蒸汽核心”吧，电源就像心脏，为机器提供源源不断的能源，所以这块板卡就是心脏卡。在选择PMIC的时候选中了BQ24610，不得不说这是颗PMIC真的坑啊啊啊啊！！第一版做出来后端系统电始终是2V，查了半天规格书没发现问题，结果找了一下TI的论坛才发现不止我一个人遇到，捣鼓捣鼓就有了下面这块板子，先上图！！！子书承宇 回板了，以后要换方案也不一定，如果功率上到百瓦这颗心脏就可能顶不住了 实物图 做了个程序 DEMO 硬件设计 BQ24610 特性简介 参考链接：https://www.ti.com.cn/document-viewer/cn/bq24610/datasheet BQ2461x 1 节至 6 节电池的独立同步降压电池充电器控制器 特性 600kHz NMOS-NMOS 同步降压转换器 适用于锂离子或锂聚合物电池的独立充电器 工作输入范围为 5V 至 28V VCC，支持 1 节至 6 节电池 (BQ24610) 工作输入范围为 5V 至 24V VCC，支持 1 节至 5 节电池 (BQ24617) 充电电流和适配器电流高达 10A 自动选择适配器或电池作为系统电源 电池检测 FET 提供反向输入保护 充电使能引脚 适用于同步降压转换器的 6V 栅极驱动 关闭状态电池放电电流 &lt; 15µA 关闭状态输入静态电流 &lt; 1.5mA 原理图 设计 原理图部分基本没什么大的问题有疑问可以去看我之前转载的文章 BQ24610锂电池充电方案 PWM直流脉冲充电 /headimg/Planck.jpg truehttps://hp-l.github.io/2024/04/09/zhuan_zai_bq24610_li_dian_chi_chong_dian_fang_an_pwm_zhi_liu_mai_chong_chong_dian 原理图设计 Layout 设计指导 以下来自TI官方论坛下载 BQ24610, BQ24616, BQ24617, BQ24618, and BQ24630 下面有翻译 Layout设计指导 Layout设计指导 Layout设计指导 指导方案： 建议采用多层PCB。至少布置两层地面。BQ24610EVM使用4层PCB(顶层，两个信号层和底层) 将输入电容尽可能靠近QH MOSFET的漏极和QL MOSFET的源极，并使用尽可能短的铜走线连接。这些部件应该放在PCB的同一层上，而不是在不同的层上，并且应该使用过孔来进行连接。 IC应放置在开关MOSFET栅极端子附近，以保持栅极驱动信号走线短，以实现干净的MOSFET驱动。IC可以放置在PCB的另一侧，与开关mosfet分开 将电感输入端尽可能靠近开关MOSFET输出端。尽量减少该走线的铜面积，以降低电场和磁场辐射，但使走线足够宽以承载充电电流。不要使用多层并联进行此连接。最小化从该区域到任何其他走线或平面的寄生电容。 充电电流感应电阻应该放在电感输出的右边。将穿过感测电阻连接的感测引线路由回同一层的IC，彼此靠近(最小化环路面积)，并且不要将感测引线路由通过大电流路径(参见开尔文连接BQ24610数据表的图27，以获得最佳电流精度)。将去耦电容放在IC旁边的这些走线上。 将输出电容放置在感应电阻输出和接地旁边。在连接系统地之前，必须将输出电容接地连接在连接输入电容接地的同一根铜线上。 模拟地与电源地分开走线，使用单一接地连接将充电器电源地绑在充电器模拟地上。在IC下方，使用倒铜作为模拟接地，但避免电源引脚，以减少电感和电容噪声耦合。使用热垫作为单地连接点，将模拟地和电源地连接在一起。或者使用0-Ω电阻将模拟地连接到电源地(在这种情况下，热垫应连接到模拟地)。强烈建议在热垫下方采用星形连接。 将IC封装背面暴露的热垫焊到PCB接地上是至关重要的。确保IC的正下方有足够的热通孔，并与其他层的接平面相连。 将去耦电容放置在IC引脚旁边，并使走线连接尽可能短。 对于给定的电流路径，所有过孔的大小和数量必须足够。 错误layout布局 错误layout布局 上图箭头是电流方向，最重大的问题应该是在于精密电阻的焊盘下方的过孔，此国控会影响BQ24610侦测电压和电流，使得输出端只能到2V。 成功的第一版本layout布局 成功layout布局 上图是按照TI给的设计图基本完全照搬做的，输入18V成功打出18V系统电。 关于充电路径 充电路径layout布局 从系统电经过表层HL MOS 电感 精密电阻 输出，这里由于有电池电压反馈，默认不插入电池该路径关闭。 电池放电路径 放电路径layout布局 通过一个 NMos 输出到系统电。 自举电容 自举电容在BUCK中有关键作用 放电路径layout布局 放电路径layout布局 放电路径layout布局 原文翻译 特性描述(续) 上部装置总是有足够的电压保持完全接通。如果BTST引脚到PH引脚的电压低于4.2 V超过3个周期，则关闭高侧n沟道功率MOSFET，打开低侧n沟道功率MOSFET，将PH节点拉下并给BTST电容充电。然后，高侧驱动器返回到100%占空比工作，直到检测到(BTST- ph)电压再次下降，因为泄漏电流使BTST电容器放电低于4.2 V，并重新发出复位脉冲。 定频振荡器在输入电压、电池电压、充电电流和温度等各种条件下都能严格控制开关频率，简化了输出滤波器的设计，使其远离可听噪声区域。关于如何选择电感、电容和MOSFET，请参见应用和实现 另一款 BUCK IC MP1484（MPS家的）规格书中写到 放电路径layout布局 原文翻译 转换器使用内部n沟道MOSFET开关将输入电压降压到调节的输出电压。由于高侧MOSFET需要大于输入电压的栅极电压，因此需要连接在SW和BS之间的升压电容器来驱动高侧栅极。当SW低时，升压电容器从内部5V轨道充电。 程序设计 函数说明 OLED部分 目前移植 0.91 OLED 成功 OLED部分 OLED部分 移植参考链接： https://github.com/yangjinhaoaa/OLED0.91-SSD1306-HAL 功率检测 功率检测 功率检测 移植参考链接： https://zhuanlan.zhihu.com/p/659846231 电池电压检测 关于电池包电压，下面表格方便查看，列出了1~20串锂电池最高最低电压以及通过分压电阻得出的电压，还有理论上ADC寄存器中的值 功率检测 bat Vbat min Vbat max Rup Rlo Vadc min Vadc max adc min adc min 1 3.7 4.2 680 100 0.474358974 0.538461538 4096 589 668 2 7.4 8.4 680 100 0.948717949 1.076923077 4096 1178 1337 3 11.1 12.6 680 100 1.423076923 1.615384615 4096 1766 2005 4 14.8 16.8 680 100 1.897435897 2.153846154 4096 2355 2673 5 18.5 21 680 100 2.371794872 2.692307692 4096 2944 3342 6 22.2 25.2 680 100 2.846153846 3.230769231 4096 3533 4010 7 25.9 29.4 680 100 3.320512821 3.769230769 4097 4122 4680 8 29.6 33.6 680 100 3.794871795 4.307692308 4098 4713 5349 9 33.3 37.8 680 100 4.269230769 4.846153846 4099 5303 6020 10 37 42 680 100 4.743589744 5.384615385 4100 5894 6690 11 40.7 46.2 680 100 5.217948718 5.923076923 4101 6484 7361 12 44.4 50.4 680 100 5.692307692 6.461538462 4102 7076 8032 13 48.1 54.6 680 100 6.166666667 7 4103 7667 8703 14 51.8 58.8 680 100 6.641025641 7.538461538 4104 8259 9375 15 55.5 63 680 100 7.115384615 8.076923077 4105 8851 10047 16 59.2 67.2 680 100 7.58974359 8.615384615 4106 9443 10720 17 62.9 71.4 680 100 8.064102564 9.153846154 4107 10036 11392 18 66.6 75.6 680 100 8.538461538 9.692307692 4108 10629 12065 19 70.3 79.8 680 100 9.012820513 10.23076923 4109 11222 12739 20 74 84 680 100 9.487179487 10.76923077 4110 11816 13413 代码部分使用ADC检测。判断电池部分使用if，简单粗暴，下面是识别1~6串代码 123456789101112131415161718192021if(ADC_Value_int &lt;= 300)&#123;\tOLED_ShowNum(110,0,0,1,16);\t&#125;if(ADC_Value_int &gt;= 588 &amp;&amp; ADC_Value_int &lt;= 689)&#123;\tOLED_ShowNum(110,0,1,1,16);\t&#125;if(ADC_Value_int &gt;= 1177 &amp;&amp; ADC_Value_int &lt;= 1337)&#123;\tOLED_ShowNum(110,0,2,1,16);\t&#125;if(ADC_Value_int &gt;= 1766 &amp;&amp; ADC_Value_int &lt;= 2005)&#123;\tOLED_ShowNum(110,0,3,1,16);\t&#125;if(ADC_Value_int &gt;= 2355 &amp;&amp; ADC_Value_int &lt;= 2674)&#123;\tOLED_ShowNum(110,0,4,1,16);\t&#125;if(ADC_Value_int &gt;= 2943 &amp;&amp; ADC_Value_int &lt;= 3342)&#123;\tOLED_ShowNum(110,0,5,1,16);\t&#125;if(ADC_Value_int &gt;= 3532 &amp;&amp; ADC_Value_int &lt;= 4011)&#123;\tOLED_ShowNum(110,0,6,1,16);\t&#125; 这个电源暂时没有计划后续做了，原本想要搭配其他板子做扫地机器人，最近时间不够承宇，暂时搁置了。不过在这里也学到了不少和 buck 升压有关的电路知识，虽然没有继续做了，但是也学到了不少。子书承宇","tags":["机器之脉络","bq24610","PMIC"],"categories":["作品"]},{"title":"kivy制作跨平台软件","path":"/2024/04/24/131251/","content":"kivy相关链接 https://kivy.org/ https://cycleuser.gitbooks.io/kivy-guide-chinese/content/ 编程环境 Anaconda 下载链接 https://docs.anaconda.com/free/anaconda/install/ 建立工程文件夹 123mkdir testcd testconda create -n kivy-study python=3.7 安装一些依赖 123pip install kivypip install buildozerpip install Cython 初始化文件夹 buildozer init 初始化生成配置文件buildozer.spec 打包apk 写一个 demo 文件 main.py12345678import kivyfrom kivy.app import Appfrom kivy.uix.button import Buttonclass hellokivy(App) : def build(self): return Button(text=&quot;hellokivy&quot;)if __name__==&quot;__main__&quot; : hellokivy().run() 时间十分漫长，一言难尽 buildozer -v android debug 成功将会出现 # Android packaging done! # APK myapp-0.1-arm64-v8a_armeabi-v7a-debug.apk available in the bin directory","tags":["python","kivy","多平台"],"categories":["应用"]},{"title":"beeware 参考","path":"/2024/04/23/181716/","content":"参考链接 https://docs.beeware.org/zh-cn/latest/","tags":["python"],"categories":["工具"]},{"title":"【转载】BQ24610锂电池充电方案 PWM直流脉冲充电","path":"/2024/04/09/091750/","content":"BQ24610锂电池充电方案 PWM直流脉冲充电 - souha - 博客园 https://www.cnblogs.com/since1996/p/13625960.html 2024-04-09 09:14:13 BQ24610锂电池充电方案 PWM直流脉冲充电 1.概述 随着移动电话、笔记本电脑、平板电脑等众多便携式电子设备的迅速普及应用，与之配套的小型锂离子电池、锂聚合物电池等二次电池的生产及需求量与日俱增，特别是锂离子电池体积小、重量轻;循环寿命长、充电可达几百次甚至上千次;自放电率低等优点广泛应用于可移动便携式电子产品中。因此，设计一套高精度锂离子充电管理系统对于锂离子电池应用是至关重要的，严格防止在电池的使用中出现过充电、过放电等现象。 目前比较成熟的锂电池充电管理方案就是基于笔记本电脑的方案，该类电源管理方案已经接近成熟，但是往往成本较高，不太符合应用于便携式分子筛制氧机设计中。结合成本与性能的考虑，最后我们选择BQ24610芯片作为主芯片，结合外围电路，来设计便携式分子筛制氧机电源管理模块。 BQ24610是TI公司生产，可以实现5V-28V锂电池充电管理。充电控制器与传统的控制器相比较，效率更高，散热更少;充电电压及电流的准确度接近百分之百，有助于延长电池使用寿命;集成型独立解决方案可提高设计灵活性，缩小整体解决方案尺寸，更有利于广泛应用于便携式设备中;动态电源管理可在电池充电时仍可为系统供电，最大限度地提高适配器功率.本文就通过在实际中的探索，对电池充电控制器和选择器芯片BQ24610的基本性能、工作原理、参数设置及应用中出现的问题进行了分析，给出了相应的典型应用电路设计。 2.BQ24610功能及特性 2.1 引脚介绍 ACN(引脚1)：适配器电流误差放大器负输入。 ACP (引脚2)：适配器电流误差放大器正输入。 ACDRV (引脚3)：交流适配器到系统MOSFET驱动器输出。 ISET1(引脚11)：快速充电电流输入设置。 ISET2 (引脚15)：预充电和终止当前输入设置。 ACSET(引脚16)：适配器当前输入设置。 VREF(引脚10)：3.3V参考电压输出。 CE(引脚4)：充电使能，逻辑高电平输入。高电平充电时能，低电平停止充电，它有一个1MΩ内部下拉电阻。 STAT1(引脚5)：漏极开路充电状态指示按钮，指示各种充电操作。 STAT2(引脚9)：漏极开路充电状态指示按钮，指示各种充电操作。 PG(引脚8)：开漏输出状态良好指示。 TS(引脚6)：电池组温度CP系数检测。 BATDRV (引脚23)：电池和系统之间的MOSFET驱动输出。防止电流从系统流向电池，将系统与电池隔离。 HIDRV(引脚21)：PWM高压侧驱动器输出。 PH(引脚20)：PWM高压侧驱动器负极电源。 BTST(引脚22)：PWM高压侧驱动器正极电源。 REGN(引脚18)：PWM低压侧驱动器正6伏电源输出。 LODRV(引脚19)：PWM低压侧驱动器输出。 SRP(引脚14)：电池电流误差放大器正输入。 SRN(引脚13)：电池电流误差放大器负输入。 VFB(引脚12)：输出电压模拟反馈调整。 TTC(引脚7)：安全时间和终止控制。 VCC(引脚24) GND(引脚17) 2.2 工作原理 锂离子电池的充电过程可以分为三个阶段：涓流充电（低压预充电）、恒流充电、恒压充电。 锂电池的充电方式是限压恒流，都是由IC芯片控制的，典型的充电方式是：先检测待充电电池的电压，如果电压低于3V，要先进行预充电，充电电流为设定电流的1/10，电压升到3V后，进入标准充电过程。 标准充电过程为： 以设定电流进行恒流充电，电池电压升到4.20V时，改为恒压充电，保持充电电压为 4.20V。此时，充电电流逐渐下降，当电流下降至设定充电电流的1/10时，充电结束 BQ24610充电电路工作原理如图2所示，该充电电路基本工作原理可分为预充、快充和终止阶段。 当接通电源，如果VBAT 快充分恒流充电和恒压充电两个阶段，在该充电阶段，恒流充电电流不变，电压持续上升，当电压达到调节电压时，充电进入恒压充电阶段。在恒压阶段，充电电流逐渐减小，BQ24610负责管理充电电流。在VTT有效情况下，如果VVFB&gt;VRECH,并且ICHARGE BQ24610能够自动选择适配器或者电池给负载供电，当处于上电状态或者睡眠模式的时候，电池连到负载。当电池跳出睡眠模式30ms,电池自动与负载断开，适配器与电池相连。一个自动闭合逻辑防止转换器转换的时候电流击穿。每次确保输出电容或者电源转换器没有充或击穿之后，进入快速充电模式，充电器自动软启动充电器调节电流。 3.便携式制氧机中的锂离子电池充电管理系统的设计与应用 依据参数要求，我们结合BQ24610的特性设计了一套适合四节锂离子电池的充放电系统，电路图如图3所示。该系统是给便携式分子筛制氧机供电，实现了以下设计： 3.1 适配器或电池供电的设计 主要通过两个P沟道的MOSFET实现。BQ24610能够自动控制实现适配器或者电池给负载供电，当系统启动或者进入睡眠模式时，电池默认与系统连接，当退出休眠模式30ms,电池自动与系统断开，适配器与系统连接。每次进入快速充电，当确定没有过充、输出电容和电源转换器没有过压现象时，系统自动软启动充电电流管理。当CE引脚的状态指示灯亮表明系统进入充电使能状态。 3.2 锂电池的电量检测与充电指示设计 通过分压法采集电池电量AD信号，通过I/O口传输给单片机，单片机对信号进行处理做出反应。电池充电状态的显示是通过两个LED灯(STAT1、STAT2)，实现充电与充电完成状态显示。当SRN与SRP之间的电压低于5mv时，芯片自动控制进入周期循环充电潜流保护，这能够阻止引起提振效应的负面感应电流。提振效应能够随着电池到输入电容的输入电压增大，导致VCC引脚过压，引起系统损坏。输入过压和低压保护，能够有效的预防过压或低压对系统造成的损坏。电池的过压保护，充电电流过流保护，热关机保护等一系列的保护措施能够大大提高系统的安全性。 3.3 系统电压低于12V时系统自动关机的设计 通过一个含有最大限制电压是30V的P沟道MOSFET和一个分流基准源实现，在此部分电路中电阻R43,R44需要满足12*R44/(R43+R44)=2.5,经计算取R43=38K,R44=10K3.4 系统按键开关的设计 含有按键开关的S1部分能够实现该功能，主要原理如下：按钮按下前，VT2的GS电压(即C1电压)为零，VT2截止，V1的GS电压为零，V1截止无输出;当按下S1,C1充电，VT GS电压上升至约3V时VT2导通，并迅速饱和，V1 GS电压小于-4V,V1饱和导通，VOUT有输出，发光管亮，C1通过R6、R12继续充电，V1、VT2状态被锁定;当再次按下按钮时，由于VT2处于饱和导通状态，漏极电压约为0VC1通过R3放电，方至约3V时，VT2截止，V1栅源电压大于-4V,V1截止，VOUT无输出，发光管灭，C1通过R6、R12及外电路继续放电，V1、VT2维持截止状。 3.5 电流电压参数的设计 3.5.1 充电电压设计 电池充电调整电压VBAT通过电池和地之间的电阻进行设定，从中间部分与VFB引脚相连。 R2在VFB和电池之间，R1在电池和地之间。 3.5.2 充电电流的设计 ISET1输入设置最大快速充电电流。蓄电池充电电流由连接在SRP和SRN之间的电阻器R SR感测。SRP和SRN之间的满标度差分电压为100mv。因此，对于10-mΩ感应电阻器，最大充电电流为10 A。充电电流的方程式为： VISET1V_ISET1VI​SET1，ISET1ISET1ISET1的输入电压范围为0 V至2 V。SRP和SRN引脚用于感应R SR上的电压，默认值为10 mΩ。但是，也可以使用其他值的电阻器。更高的准确度和更高的电阻感，但更大的损失。 3.5.3 适配器输入电流的设计 来自交流适配器AC或其他直流电源的总输入是系统电源电流和蓄电池充电电流的总和。系统电流通常随着部分系统通电或断电而波动。没有DPM，电源必须能够同时提供最大系统电流和最大充电电流。而使用DPM，当输入电流超过ACSET设定的输入电流限制时，电池充电器可降低充电电流，降低系统损耗。与设置电池充电电流类似，适配器电流由连接在ACP和ACN之间的电阻器RAC感应。其最大值由ACSET使用方程式3设定： V ACSET，ACSET的输入电压范围为0 V至2 V。ACP和ACN引脚用于感应交流电压，默认值为10 mΩ。但是，也可以使用其他值的电阻器。感测电阻越大，感应电压越大，调节精度也越高，但以较高的传导损耗为代价。 3.5.4 预充电电流的设计 通电时，如果蓄电池电压低于V低电压阈值，bq2461x会向蓄电池施加预充电电流。此功能旨在使深度放电的细胞复活。如果在启动预充电后30分钟内未达到V低电压阈值，充电器将关闭，状态引脚上会显示故障。预充电电流由ISET2引脚上的电压V ISET2决定。 3.5.5 充电终止电流、安全计时器 bq2461x在电压调节阶段监控充电电流。当V TTC有效时，当VFB管脚上的电压高于V RECH阈值且充电电流小于I项阈值时检测到终端，如等式5所计算： (充电终止电流) ISET2的输入电压为0 V至2 V。使用默认的10 mΩ感应电阻器，最小预充电/端接电流钳制在125 mA左右。作为安全备份，bq2461x还提供了一个可编程的充电计时器。充电时间由连接在TTC引脚和GND之间的电容器编程，由等式6给出: 其中,K TTC是常数，K TTC=5.6 min/nF。 当出现以下任一情况时，将启动新的充电循环并重置安全计时器： •电池电压低于充电阈值。 •发生上电复位（POR）事件。 •CE已切换。 TTC引脚可能被调低以禁用终端和安全定时器。如果TTC被拉到VREF，bq2461x继续允许终止，但禁用安全计时器。TTC取低重置安全计时器。什么时候ACOV、VCCLOWV和休眠模式恢复正常，安全计时器复位。 3.5.6 VCC上电 bq2461x使用休眠比较器来确定VCC引脚上的电源，因为VCC可以由电池或适配器供电。如果VCC电压大于SRN电压，bq2461x启用ACFET并禁用BATFET。如果满足所有其他充电条件，bq2461x将尝试对电池充电（请参阅启用和禁用充电）。 如果SRN电压大于VCC，表明电池是电源，bq2461x启动BATFET并进入低静态电流（&lt;15μa）休眠模式，以最大限度地减少电池的电流消耗。如果VCC低于UVLO阈值，则设备被禁用，ACFET关闭，BATFET打开。 3.5.7 启用和禁用充电 启用充电前，以下条件必须有效： •CE高。 •设备未处于欠压锁定（UVLO）和VCCLOWV模式。 •设备未处于睡眠模式。 •VCC电压低于交流过电压阈值（VCC&lt;V ACOV）。 •初始通电后30 ms延迟完成。 •REGN LDO和VREF LDO电压处于正确水平。 •热关机（TSHUT）无效。 •未检测到TS故障。 下列情况之一将停止持续充电： •CE低。 •适配器已卸下，导致设备进入UVLO、VCCLOWV或睡眠模式。 •适配器电压过高。 •REGN或VREF LDO过载。 •t达到关闭IC温度阈值（上升沿145°C，滞后15°C）。 •TS电压超出范围，表明电池温度过高或过低。 •TTC安全计时器超时。 3.5.8 系统电源选择器 bq2461x自动将适配器或电池电源切换到系统负载。在开机或休眠模式下，电池默认连接到系统。电池与系统断开连接，然后适配器在退出休眠30毫秒后连接到系统。一个自动断开-关合逻辑可防止选择器切换时的击穿电流。 ACDRV用于驱动适配器和ACP之间的一对背靠背P沟道功率MOSFET，S极连接在一起并连接到VCC。连接到适配器上的FET防止电池在关闭时向适配器反向放电。与肖特基二极管相比，带有漏极连接到适配器输入端的P沟道FET在关闭时提供反向电池放电保护；同时，与肖特基二极管相比，它的低Rds（on） (MOS管导通电阻)也使系统功耗最小化。另一个连接到ACP的Pmos将电池与适配器分离，并通过控制FET开启时间在将适配器连接到系统时提供有限的dI/dt。BATDRV控制一个位于BAT和系统之间的P沟道功率MOSFET。 当没有检测到适配器时，ACDRV被拉到VCC以保持ACFET关闭，断开适配器与系统的连接。BATDRV保持ACN-6V电压，将电池连接至系统。 在设备从休眠模式出来大约30毫秒后，系统开始从电池切换到适配器。先断后合逻辑使ACFET和BATFET在ACFET开启前关闭10µs。这防止了射电电流或任何大放电电流进入电池。BATDRV被拉至ACN，ACDRV引脚由内部调节器设置为VCC-6V，以打开P通道ACFET，将适配器连接到系统。 卸下适配器后，系统将等待VCC降至SRN以上200 mV以内，然后从适配器切换回电池。先断后合逻辑仍保持10μs的死区时间。ACDRV被拉至VCC，BATDRV引脚由内部调节器设置为ACN-6V，以打开P通道BATFET，将电池连接至系统。 用于ACDRV和BATDRV驱动器的非对称栅极驱动（快速关断和慢导通）提供ACFET和BATFET的快速关断和慢导通，以帮助实现先断后合逻辑，并允许在任一FET接通时软启动。通过在P沟道功率mosfet的栅极到源端放置电容器，可以进一步提高软启动时间。 3.5.9 自动内部软启动充电器电流 每次充电器快速充电时，充电器都会自动软启动充电器调节电流，以确保输出电容器或电源转换器没有过冲或应力。软启动包括将充电调节电流分为八个等分步骤，直到编程的充电电流。每个步骤持续约1.6毫秒，典型上升时间为12.8毫秒。此功能不需要外部组件。 3.5.10 变频器操作 同步buck-PWM变换器采用固定频率电压模式和前馈控制方案。III型补偿网络允许在转换器的输出端使用陶瓷电容器。补偿输入级内部连接在反馈输出（FBO）和误差放大器输入（EAI）之间。反馈补偿级连接在误差放大器输入（EAI）和误差放大器输出之间 （EAO）。选择LC输出滤波器，使bq2461x的谐振频率为12 kHz至17 kHz，其中谐振频率f o由以下公式给出： 将内部锯齿形斜坡与内部EAO错误控制信号进行比较，以改变转换器的占空比。斜坡高度为输入适配器电压的7%，使其始终与输入适配器电压成正比。这消除了由于输入电压变化而引起的任何环路增益变化，并简化了环路补偿。当占空比小于300%时，允许斜坡信号的占空比为300%。EAO信号也允许超过锯齿波斜坡信号，以获得100%的占空比PWM请求。内部门驱动逻辑允许实现99.5%的占空比，同时确保N通道上部设备始终有足够的电压保持完全开启。如果BTST引脚到PH引脚的电压下降到4.2 V以下超过3个周期，则高侧N沟道功率MOSFET关闭，低侧N沟道功率MOSFET被打开，以拉低PH节点电位并对BTST电容器充电。然后，高压侧驱动器返回到100%占空比(通电时间占比)运行，直到检测到（BTST-PH）电压再次下降，因为泄漏电流使BTST电容器放电低于4.2V，然后重新发出复位脉冲。固定频率振荡器在输入电压、电池电压、充电电流和温度的所有条件下都能严格控制开关频率，简化了输出滤波器的设计，并使其远离可听见的噪声区域。另请参阅应用和实施，了解如何选择电感器、电容器和MOSFET。 3.5.11 同步和非同步运行 当SRP-SRN电压高于5 mV（10 mΩ感应电阻器的电感电流为0.5 A）时，充电器以同步模式工作。在同步模式下，内部门驱动逻辑确保在进行互补切换之前有断路，以防止击穿电流。在两个fet都关闭的30ns死区时间内，低侧功率MOSFET的体二极管传导电感电流。有低边场效应晶体管打开保持低功耗，并允许在高电流安全充电。在同步模式下，电感器电流始终流动，转换器以连续导通模式（CCM）运行， 创建固定的两极系统。 当SRP-SRN电压低于5 mV（10 mΩ感应电阻器的电感电流为0.5 A）时，充电器以非同步模式工作。当电池电压低于2 V或SRP-SRN平均电压低于1.25 mV时，充电器被迫进入非同步模式。 在非同步工作时，下侧MOSFET的体二极管可以在高侧N沟道功率MOSFET关断后导通正电感电流。当负载电流降低，电感器电流降到零时，体二极管关闭，电感器电流不连续。这种模式称为不连续传导模式（DCM）。在DCM过程中，当自举电容电压下降到4.2V以下时，低侧N沟道功率MOSFET打开约80ns；然后低压侧功率MOSFET关闭并保持关闭状态，直到下一个循环开始，此时高压侧功率MOSFET再次打开。80纳秒的低侧MOSFET通电时间要求，以确保引导电容始终充电，并能够保持高侧功率MOSFET在下一个循环中接通。这对电池充电器很重要，不像普通的DC-DC转换器，有一个电池负载可以维持电压，并且可以产生和吸收电流。80ns的低压侧脉冲拉低PH节点（高、低压侧MOSFET之间的连接），允许自举电容器重新充电到REGN LDO值。80ns后，低侧MOSFET保持关闭，以防止出现负电感电流。 在非同步运行期间的极低电流下，80ns充电脉冲期间可能会有少量的负电感电流。电荷应足够低，以被输入电容吸收。每当转换器进入0%的占空比时，高侧MOSFET不导通，低侧MOSFET也不导通（只有80ns充电脉冲），电池几乎没有放电。 在DCM模式下，回路响应会自动改变，并且有一个极点与负载电流成比例的单极系统，因为转换器不吸收电流，只有负载提供电流汇。这意味着在非常低的电流下，回路响应较慢，因为可以释放输出电压的陷波电流较少。 3.5.12 循环充电欠电流保护 如果SRP-SRN电压降低到5 mV以下（当平均SRP-SRN电压低于1.25 mV时，充电器也被迫进入非同步模式），则在剩余的开关周期内关闭低压侧FET，以防止出现负电感电流。在DCM过程中，当自举电容电压降到4.2v以下时，低侧FET只开启约80ns，为自举电容提供刷新电荷。这对于防止负电感器电流引起输入电压升高的升压效应非常重要，因为电源从电池传输到输入电容器，导致VCC节点上的过电压应力，并可能导致系统损坏。 3.5.13 输入过压保护（ACOV） ACOV提供保护，防止高输入电压导致系统损坏。一旦适配器电压达到ACOV阈值，充电将被禁用，系统将切换到电池而不是适配器。 3.5.14 输入欠压锁定(UVLO) 系统必须具有最小VCC电压，以允许正常工作。此VCC电压可能来自输入适配器或电池，因为存在从电池到VCC的传导路径，通过高压侧NMOS主体二极管。当VCC低于UVLO阈值时，IC上的所有电路都被禁用，ACFET和BATFET的栅极驱动偏置也被禁用。 3.5.15 电池过电压保护 转换器不允许高侧场效应晶体管打开，直到电池电压低于102%的调节电压。这允许对过电压条件作出一个周期的响应，例如在卸下负载或断开蓄电池时发生的情况。从SRP到GND的8毫安电流接收器仅在充电期间打开，并允许将存储的输出电感器能量放电到输出电容器。BATOVP还暂停了安全计时器。 3.5.16 循环充电过电流保护 充电器具有二次循环对循环过电流保护。它监控充电电流，防止电流超过编程充电电流的160%。当检测到过电流时，高压侧栅极驱动关闭，当电流降至过电流阈值以下时自动恢复驱动。 3.5.17 热关断保护 QFN封装具有低的热阻抗，从硅到环境提供良好的热传导，以保持结温低。作为附加保护级别，每当结温超过145°C的TSHUT阈值时，充电器转换器关闭并自我保护。充电器保持关闭状态，直到结温降至130°C以下；然后，如果所有其他启用充电条件都有效，充电器将再次软启动。热关机也会暂停安全计时器。 3.5.18 温度限定条件 控制器通过测量TS引脚和GND之间的电压来持续监测电池温度。负温度系数热敏电阻（NTC）和外部分压器通常产生这种电压。控制器将该电压与其内部阈值进行比较，以确定是否允许充电。要启动充电循环，电池温度必须在V LTF至V HTF阈值范围内。如果电池温度超出此范围，控制器将暂停充电和安全计时器，并等待电池温度在V LTF到V HTF范围内。在充电周期内，电池温度必须在V LTF到V TCO阈值范围内。如果电池温度超出该范围，控制器将暂停充电并等待，直到电池温度在V LTF至V HTF范围内。控制器通过关闭PWM充电fet来暂停充电。图14总结了该操作。 假设电池组上有一个103AT的NTC热敏电阻，如图19所示，可使用以下公式确定值RT1和RT2： 例如，103AT NTC热敏电阻用于监测电池组温度。选择T冷=0ºC，T截止=45ºC；则R T2=430 kΩ，R T1=9.31 kΩ。建议使用小型RC滤波器进行系统级ESD保护。 3.5.19 计时器故障恢复 bq2461x提供了一种恢复方法来处理定时器故障情况。下文对此进行了总结 方法： 情况1：蓄电池电压高于充电阈值，出现超时故障。恢复方法：当电池电压低于充电阈值时，定时器故障清除，电池检测开始。采用CE低或POR条件也可以清除故障。 情况2：蓄电池电压低于充电阈值，出现超时故障。恢复方法：在这种情况下，bq2461x对电池施加I故障电流。此小电流用于检测蓄电池拆卸情况，只要蓄电池电压保持在充电阈值以下，该电流就会保持接通。如果电池电压高于充电阈值，bq2461x将禁用故障电流并执行条件1中所述的恢复方法。采用CE低或POR条件也可以清除故障。 3.5.20 CE（充电使能） 开路漏极PG（功率良好）输出指示VCC电压是否有效。当bq2461x有一个有效的VCC输入（不在UVLO、ACOV或睡眠模式下）时，开路漏极FET就会打开。PGpin可用于驱动LED或与主机处理器通信。 3.5.21 充电状态 CE数字输入用于禁用或启用充电过程。如果满足所有其他充电条件，此引脚上的高电平信号将启用充电（请参阅启用和禁用充电）。此引脚上的高到低转换也会重置所有计时器和故障条件。CE引脚上有一个内部1 MΩ下拉电阻器，因此如果CE浮动，充电不会开启。 3.5.22 电池检测输出 开路漏极STAT1和STAT2输出指示各种充电器操作，如表2所示。这些状态引脚可用于驱动LED或与主机处理器通信。关表示开漏晶体管关断。 4.结论 通过试验结果分析，充电电压在12.6V左右浮动，准确度超过95%,充电电流在3A左右浮动，准确度超过99%.系统的输入过压过流保护、电池的过压、过流保护，高温保护准确度达到了99%.经过多次试验该电路能其要求的功能。 本文系统地分析了锂离子电池充电控制集成电路芯片应用中常用到的技术问题，并给出了在便携式制氧机中的典型应用实例。根据系统对电池的应用需求，通过合理设置BQ24610的外部元件参数，就可构成一个功能完备的锂离子电池充电器。该设计能够很好的实现系统锂离子电池充电器的功能，可作为有关设计人员对电池充电器进一步开发的参考。该类集成芯片系列较多，但在使用方法上存在许多类似之处，这使得本文的分析讨论在实际应用中具有重要的实用价值和参考价值，为电池充电电路设计者提供了有用的参考，同时也可为其他电子元件的应用提供参考。 应用电路图 PCB设计 官方建议 开关节点的上升和下降时间应最小化，以使开关损耗最小。部件的合理布局以尽量减少高频电流路径回路（见图23）对于防止电磁场辐射和高频共振问题非常重要。下面是一个正确布局的PCB布局优先级列表。根据这个特定的顺序来布置PCB是必要的。 将输入电容器尽可能靠近开关MOSFET电源和接地连接，并使用尽可能短的铜迹线连接。这些零件应该放在PCB的同一层上，而不是放在不同的层上，并使用通孔进行连接。 集成电路应放置在靠近开关MOSFET栅极端子的地方，以保持栅极驱动信号的轨迹较短，以便进行干净的MOSFET驱动。集成电路可以放置在开关MOSFET的PCB层的背面。 将电感器输入端尽可能靠近开关MOSFET输出端。尽可能减小该轨迹的铜面积，以降低电场和磁场辐射，但应使该轨迹足够宽以承载充电电流。请勿将多层并行用于此连接。最小化从这个区域到任何其他轨迹或平面的寄生电容。 电流采样电阻应该放在电感输出的旁边。将穿过采样电阻的感测引线布线回同一层中的IC，彼此靠近（尽量减少回路面积），不要将感测引线穿过高电流路径（有关最佳电流精度的开尔文连接，请参见图24）。将去耦电容器放在IC旁边。 将输出电容器放在感应电阻输出和接地旁边。 在连接到系统接地之前，输出电容器必须与连接到输入电容共地。 将模拟地(AGND)与电源地(GND)分开布线，并使用一个接地连接将GND连接到AGND。就在集成电路下面，使用铺铜模拟接地，但要避免电源引脚，以减少感应和电容噪声耦合。将AGND连接到GND。使用热垫作为单个接地连接点，将AGND和GND连接在一起。或者使用一个0Ω的电阻将AGND连接到GND（在这种情况下，热垫应连接到AGND）。强烈建议在热垫下使用星形连接。 将IC封装背面裸露的热焊盘焊接到PCB地上，这是至关重要的。确保IC正下方有足够的热通孔，连接到其他层的接地层。 将去耦电容器放在IC引脚旁边，并使跟踪连接尽可能短。 所有过孔的大小和数量必须足以满足给定的当前路径 PCB一般要求 除此之外还要注意电流与线宽、铜厚之间的关系 差分线: 尽量减少高频电流路径回路 bq2461x设备是一个独立的集成锂离子或锂聚合物电池充电器。该装置采用开关频率恒定的开关模式同步降压PWM控制器。该设备控制外部开关，以防止电池放电回输入，连接适配器到系统，并使用6伏栅极驱动器将电池连接到系统，以提高系统效率。bq2461x的特点是动态电源管理(DPM)，当达到输入功率限制时降低电池充电电流，以避免在同时向系统和电池充电器供电时AC适配器过载。一个高度精确的电流感应放大器可以精确测量来自交流适配器的输入电流，以监测整个系统的功率。输入电流限制可通过设备的ACSET引脚配置。bq2461x有一个电池检测方案，允许它自动检测电池的存在和缺少。当电池被检测到时，充电开始于三个阶段之一(取决于电池电压):预充电、恒流(快速充电电流调节)和恒压(快速充电电压调节)。当达到终止电流阈值时，设备将终止充电。当电池电压降至充电阈值(V RECHG)以下时，开始一个充电周期。可通过ISET1和ISET2引脚配置预充电、恒流和终止电流，使电池充电配置更加灵活。在充电过程中，设备集成了电池过压保护、电池短路检测(V BATSHT)、热关机(内部T SHUT和TS引脚)、安全定时器过期(TTC引脚)、输入电压保护(V ACOV)等故障监控，确保电池安全。bq2461x有三个状态引脚(STAT1, STAT2, PG)来指示充电状态和输入电压(AC适配器)状态。这些引脚可以用来驱动led或与主机处理器通信。 上图额定参数: 为使bq2461x正常工作，VCC必须为5 V至28 V（bq24610）或24 V（bq24617）。要开始充电，VCC必须高于SRN至少500毫伏（否则，设备将处于休眠模式）。TI建议输入电压至少比电池电压高1.5 V到2 V，考虑到高侧FET（Rdson）、电感器（DCR）和输入感测电阻（ACP和ACN之间）的直流损耗、VCC和输入电源之间的RBFET体二极管压降以及电池感应电阻（SRP和SRN之间）。输入电源的功率限制必须大于系统负载或电池充电所需的最大功率（两者中的较大者）。","tags":["机器之脉络","BQ24610","电源管理"],"categories":["理论"]},{"title":"STM32 HAL DHT11","path":"/2024/03/22/201232/","content":"记录一次CUBEIDE的DHT11代码调试 文末有贴代码，亲测可用 STM32CUBEIDE 首先本文是基于STM32官方出品的CUBEIDE进行代码编写和调试的 环境搭建 官网下载之后安转完成（软件安装后可能需要登录才可以下载相关库文件） 新建工程网上已经有很多博主写了，直接略过。关于DHT11除了一些基本配置（如外部晶振、调试接口等）需要使用的一些配置如下图： 注意生成代码记得勾选Generate peripheral initialization as a pair of'.c/.h' files per peripheral Tim配置 本文选择Tim3，配置如图： USART配置 本文选择Uart3，配置如图： GPIO配置 本文选择GPIOB12，配置如图： 配置完成保存生成代码 手动添加代码如下 导入h文件，添加变量 打开串口中断初始化DHT11 获取DHT11数据以及数据类型转换和串口发送 下图可以看出获取到的温度数据 程序集合 需要修改项 在文件dht11.h搜索#define DHT11_DATA_OUT_Pin GPIO_PIN_12、#define DHT11_DATA_OUT_GPIO_Port GPIOA换成自己定义的GPIO。 在文件dht11.c搜索htim3，换成自己想要的定时器。 main.c 函数中需要先定义初始化dht11，之后进行读温度湿度、注意DHT11是5V供电 如需添加串口中断函数可以直接添加在main.c中的/* USER CODE BEGIN 4 */位置 DHT11.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197#include &quot;DHT11.h&quot;#include &quot;tim.h&quot;#define DHT11_DQ_IN HAL_GPIO_WritePin(DHT11_GPIO_Port, DHT11_Pin, GPIO_PIN_SET) //输入void DelayUs(uint32_t nus)&#123; uint16_t differ = 0xffff - nus - 5; //设置定时器2的技术初始值 __HAL_TIM_SetCounter(&amp;htim3, differ); //开启定时器 HAL_TIM_Base_Start(&amp;htim3); while( differ &lt; 0xffff - 5) &#123; differ = __HAL_TIM_GetCounter(&amp;htim3); &#125;;//关闭定时器 HAL_TIM_Base_Stop(&amp;htim3);&#125;void DelayXms(unsigned char t)&#123; HAL_Delay(t);&#125;//初始化DHT11，同时检测是否连接上DHT11，PA11初始化uint8_t DHT11_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStruct = &#123;0&#125;; /* GPIO Ports Clock Enable */ __HAL_RCC_GPIOA_CLK_ENABLE(); /*Configure GPIO pin Output Level */ HAL_GPIO_WritePin(GPIOA, DHT11_DATA_OUT_Pin, GPIO_PIN_SET); /*Configure GPIO pin : PtPin */ GPIO_InitStruct.Pin = DHT11_DATA_OUT_Pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_PULLDOWN; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(DHT11_DATA_OUT_GPIO_Port, &amp;GPIO_InitStruct); DHT11_Rst(); return DHT11_Check();&#125;//复位DHT11void DHT11_Rst(void)&#123; DHT11_IO_OUT(); //SET OUTPUT HAL_GPIO_WritePin(GPIOA, DHT11_DATA_OUT_Pin, GPIO_PIN_RESET); //拉低 DelayXms(20); //拉低延时至少18ms HAL_GPIO_WritePin(GPIOA, DHT11_DATA_OUT_Pin, GPIO_PIN_SET); //DQ=1，拉高 DelayUs(30); //拉高延时至少20~40us&#125;//检测回应//返回1：检测错误//返回0：检测成功uint8_t DHT11_Check(void)&#123; uint8_t retry = 0; DHT11_IO_IN();//SET INPUT while (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_12) &amp;&amp; retry &lt; 100) //DHT11拉低40~80us &#123; retry++; DelayUs(12); &#125;; if(retry &gt;= 100)return 1; else retry = 0; while (!HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_12) &amp;&amp; retry &lt; 100) //DHT11再次拉高40~80us &#123; retry++; DelayUs(1); &#125;; if(retry &gt;= 100)return 1; return 0;&#125;//读取一个位Bit//返回1或0uint8_t DHT11_Read_Bit(void)&#123; uint8_t retry = 0; while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_12) &amp;&amp; retry &lt; 100) //等待变低电平 &#123; retry++; DelayUs(1); &#125; retry = 0; while(!HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_12) &amp;&amp; retry &lt; 100) //等待变高电平 &#123; retry++; DelayUs(1); &#125; DelayUs(40);//等待40us if(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_12))return 1; else return 0;&#125;//读取一个字节//返回读到的数据uint8_t DHT11_Read_Byte(void)&#123; uint8_t i, dat; dat = 0; for (i = 0; i &lt; 8; i++) &#123; dat &lt;&lt;= 1; dat |= DHT11_Read_Bit(); &#125; return dat;&#125;//DHT11读取一次数据//temp:温度(范围:0~50°)//humi:湿度(范围:20%~90%)//tem：温度小数位//hum：湿度小数位uint8_t DHT11_Read_Data(uint8_t *temp, uint8_t *humi, uint8_t *tem, uint8_t *hum)&#123; uint8_t buf[5]; uint8_t i; DHT11_Rst(); if(DHT11_Check() == 0) &#123; for(i = 0; i &lt; 5; i++) //读取40位字节 &#123; buf[i] = DHT11_Read_Byte(); &#125; if((buf[0] + buf[1] + buf[2] + buf[3]) == buf[4]) &#123; *humi = buf[0]; *hum = buf[1]; *temp = buf[2]; *tem = buf[3]; &#125; &#125; else return 1; return 0;&#125;//DHT11输出模式配置void DHT11_IO_OUT()&#123; GPIO_InitTypeDef GPIO_InitStruct = &#123;0&#125;; /* GPIO Ports Clock Enable */ __HAL_RCC_GPIOA_CLK_ENABLE(); /*Configure GPIO pin Output Level */ HAL_GPIO_WritePin(GPIOA, DHT11_DATA_OUT_Pin, GPIO_PIN_SET); /*Configure GPIO pin : PtPin */ GPIO_InitStruct.Pin = DHT11_DATA_OUT_Pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_PULLDOWN; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(DHT11_DATA_OUT_GPIO_Port, &amp;GPIO_InitStruct);&#125;//DHT11输入模式配置void DHT11_IO_IN(void)&#123; GPIO_InitTypeDef GPIO_InitStruct = &#123;0&#125;; /* GPIO Ports Clock Enable */ __HAL_RCC_GPIOA_CLK_ENABLE(); /*Configure GPIO pin : PC0 */ GPIO_InitStruct.Pin = GPIO_PIN_12; GPIO_InitStruct.Mode = GPIO_MODE_INPUT; GPIO_InitStruct.Pull = GPIO_PULLUP; HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);&#125; DHT11.h 123456789101112131415161718#ifndef _DHT11_H_#define _DHT11_H_#include &quot;main.h&quot;#include &quot;stdlib.h&quot;#define DHT11_DATA_OUT_Pin GPIO_PIN_12#define DHT11_DATA_OUT_GPIO_Port GPIOAvoid DHT11_Rst(void);uint8_t DHT11_Check(void);uint8_t DHT11_Read_Bit(void);uint8_t DHT11_Read_Byte(void);uint8_t DHT11_Read_Data(uint8_t *temp,uint8_t *humi,uint8_t *tem,uint8_t *hum);uint8_t DHT11_Init(void);void DHT11_IO_IN(void);void DHT11_IO_OUT(void);#endif 串口中断函数 12345678910111213141516171819202122232425262728293031323334353637383940/* USER CODE BEGIN 4 *//** * @brief Interrupt_UARTX_接收 * @retval None */void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)&#123; /* 串口 3 中断 */ if(huart == (&amp;huart3)) &#123; //接收字符 HAL_UART_Transmit(&amp;huart3, &amp;kRxBuffer, 10, 100); //�??启中�?? HAL_UART_Transmit_IT(&amp;huart3, &amp;kRxBuffer, 100); /* z */ &#125;&#125;/** * @brief Interrupt_UARTX_发�?? * @retval None */void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)&#123; /* 串口�?????? */ if(huart == (&amp;huart3)) &#123; //发�?�数�?? HAL_UART_Receive(&amp;huart3, &amp;kRxBuffer, 10, 100); //打开中断 HAL_UART_Receive_IT(&amp;huart3, &amp;kRxBuffer, 100);// HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin); &#125;&#125;/* USER CODE END 4 */","tags":["dht11","stm32","cubeide"],"categories":["应用"]},{"title":"章节1-新鼹纪","path":"/2024/03/21/133539/","content":"新鼹纪 人类这一科让世界变得多样化，不确定性逐步增加，地球再也绷不住了，做了一个几千万年前决定，重启！地球恶劣天气日益增多，山洪地震海啸地裂让熔岩再次有了可乘之机，汤加火山持续喷发，堆积的熔岩从大洋底部一直堆积，在大洋海面形成了小岛，持续飞扬的火山灰挡住了太阳的光和热，一切都冷了下来。海洋结成了冰，压着地壳喘不过气来。冰面把光和热反射想宇宙，本就寒冷的地球更加寒冷，太阳看着他的卫三叹了口气，全球极光持续了一年…… 只可惜，这次重启，不太彻底…… ……五千万年后…… 一只肉乎乎的小手从土里伸了出来，一只近似星鼻鼹属的生物苟延残喘的活到了现在爬出了土层，开始探索这片自己也看不见的世界 ……又三千万年…… 新鼹纪 241 万年 鼹民新闻播报：今日 31 时左右，我国考古学家在 2114 鼹摆 （2000 米）深度处挖掘出来灵长类动物化石，按照同位素法时间推算，距今约有六千万到七千万年。 ​鼹这一属统治了地球……","tags":["科幻随想"],"categories":["杂谈"]},{"title":"git图形化工具","path":"/2024/03/20/192156/","content":"图形化管理git https://www.sourcetreeapp.com/ 参考教程 https://www.liaoxuefeng.com/wiki/896043488029600/1317161920364578","tags":["git"],"categories":["工具"]},{"title":"arduino使用TFT_eSPI库(ST7735)","path":"/2024/03/14/082156/","content":"环境配置 搜索下载TFT_eSPI库 进入文件夹C:\\Users\\xx\\Documents\\Arduino\\libraries\\TFT_eSPI，有文件User_Setup.h和User_Setup_Select.h User_Setup.h修改 选择对应的液晶屏驱动芯片 配置颜色显示顺序 ST7789芯片中MADCTL (36h)寄存器的第3位控制像素颜色顺序 配置屏幕尺寸 配置屏幕颜色模式 定义Pin脚 配置需要用到的字体（会占用单片机存储空间） 配置SPI频率 User_Setup_Select.h修改 写st7789.ino 12345678910111213141516#include &lt;Arduino.h&gt;#include &lt;ArduinoJson.h&gt;#include &lt;TFT_eSPI.h&gt;void setup(void) &#123; TFT_eSPI tft = TFT_eSPI(); TFT_eSprite clk = TFT_eSprite(&amp;tft); tft.init(ST7735_BLACK); tft.setRotation(1); tft.fillScreen(TFT_BLACK); tft.fillRect(tft.width() / 2, tft.height() / 2, 50, 50, TFT_RED);&#125;void loop() &#123;&#125; 常用函数 参考链接：https://blog.csdn.net/finedayforu/article/details/108975245","tags":["arduino","C++"],"categories":["应用"]},{"title":"开源字体集合","path":"/2024/03/06/111223/","content":"落霞孤鹜 链接地址：https://lxgw.github.io/ 自改免费开源字体一览 悠哉字体 / Yozai (猫啃) 霞鹜文楷 / LXGW WenKai (猫啃) 在线版本 霞鹜文楷屏幕阅读版 网络字体仓库 京華老宋体 链接地址：https://zhuanlan.zhihu.com/p/637491623","tags":["字体"],"categories":["其他"]},{"title":"博客字体超级压缩","path":"/2024/03/02/221707/","content":"安装依赖 123npm install --global gulp-cli #全局安装gulp指令集npm install gulp --save #安装gulp插件npm install --save-dev gulp-fontmin 脚本编写 在博客根目录新建gulpfile.js 12345678910111213141516171819202122232425262728293031var gulp = require(&quot;gulp&quot;);var fontmin = require(&quot;gulp-fontmin&quot;);function minifyFont(text, cb) &#123; gulp .src(&quot;source/font/*.ttf&quot;) //原字体所在目录 .pipe( fontmin(&#123; text: text, &#125;) ) .pipe(gulp.dest(&quot;source/fontdest/&quot;)) //压缩后的输出目录 .on(&quot;end&quot;, cb);&#125;gulp.task(&quot;mini-font&quot;, (cb) =&gt; &#123; var buffers = []; gulp .src([&quot;./.deploy_git/**/*.html&quot;]) //HTML文件所在目录请根据自身情况修改 .on(&quot;data&quot;, function (file) &#123; buffers.push(file.contents); &#125;) .on(&quot;end&quot;, function () &#123; var text = Buffer.concat(buffers).toString(&quot;utf-8&quot;); minifyFont(text, cb); &#125;);&#125;);gulp.task(&quot;default&quot;, gulp.parallel(&quot;mini-font&quot;)); 引入字体到主题文件中 12345@font-face &#123; font-family: &quot;LXGW&quot;; /* 字体名自定义即可 */ src: url(&quot;/fontdest/霞鹜文楷.ttf&quot;); /* 字体文件路径 */ font-display: swap;&#125; 压缩命令 终端输入gulp","tags":["字体","压缩"],"categories":["应用"]},{"title":"SCT2650电源设计","path":"/2024/03/01/091632/","content":"SCT2650 本文介绍一款DCDC的芯片，SCT2650STER：4.5V-60V Vin, 5A，高效率降压DCDC转换器，可编程频率(4.5V-60V Vin, 5A, High Efficiency Step-down DCDC Converter with Programmable Frequency) 规格书摘要 产品特点 Wide Input Range: 4.5V-60V Up to 5A Continuous Output Current 0.8V ±1% Feedback Reference Voltage Adjustable Frequency 100KHz to 1.2MHz 大致的电气特性 3.3V参考设计： PIN Function Switching Frequency 输出电压 500KHz典型输出电压参考表 规格书中还提到有逆变器方面的应用(Inverting Power application) 这颗IC在24V输入3.3V输出5A电流时，温度高达92°C 在IC下方有一个大面积阻焊层连接到IC目的就是更好地散热 Layout 设计参考 线上图 Proper PCB layout is a critical for SCT2650’s stable and efficient operation. The traces conducting fast switching currents or voltages are easy to interact with stray inductance and parasitic capacitance to generate noise and degrade performance. For better results, follow these guidelines as below: Power grounding scheme is very critical because of carrying power, thermal, and glitch/bouncing noise associated with clock frequency. The thumb of rule is to make ground trace lowest impendence and power are distributed evenly on PCB. Sufficiently placing ground area will optimize thermal and not causing over heat area. Place a low ESR ceramic capacitor as close to VIN pin and the ground as possible to reduce parasitic effect. Freewheeling diode should be place as close to SW pin and the ground as possible to reduce parasitic effect. For operation at full rated load, the top side ground area must provide adequate heat dissipating area. Make sure top switching loop with power have lower impendence of grounding. The bottom layer is a large ground plane connected to the ground plane on top layer by vias. The power pad should be connected to bottom PCB ground planes using multiple vias directly under the IC. The center thermal pad should always be soldered to the board for mechanical strength and reliability, using multiple thermal vias underneath the thermal pad. Improper soldering thermal pad to ground plate on PCB will cause SW higher ringing and overshoot besides downgrading thermal performance. it is recommended 8mil diameter drill holes of thermal vias, but a smaller via offers less risk of solder volume loss. On applications where solder volume loss thru the vias is of concern, plugging or tenting can be used to achieve a repeatable process. Output inductor and freewheeling diode should be placed close to the SW pin. The switching area of the PCB conductor minimized to prevent excessive capacitive coupling. The RT/CLK terminal is sensitive to noise so the RT resistor should be located as close as possible to the IC and routed with minimal lengths of trace. UVLO adjust and RT resistors, loop compensation and feedback components should connect to small signal ground which must return to the GND pin without any interleaving with power ground. Route BOOT capacitor trace on the other layer than top layer to provide wide path for topside ground. For achieving better thermal performance, a four-layer layout is strongly recommended. 我的线路设计 Layout 设计 验证 功能待验证","tags":["机器之脉络","DCDC"],"categories":["应用"]},{"title":"音频PCB设计学习与总结","path":"/2024/02/29/185959/","content":"最近在看音频功放类电路设计，也就是HiFi电路，其中涉及模拟电路和数字电路，在模拟电路中放大器将小信号放大的过程中，如果高频也就是数字地或者数字电路对模拟电路产生耦合，那么噪声也会被小信号放大电路所放大，于是就产生了杂音，音质不高。参考了做博客目前还没有实际做出成品，先了解学习一下。 如何有效地接地 在音频PCB设计中，单点接地和大面积铺地都是为了减少噪声和提高信号完整性。它们并不是相互排斥的概念，而是可以根据具体情况和设计需求灵活应用的。 单点接地的主要优点在于能够有效地隔离不同功能模块之间的地回路，从而减少由于地环路产生的噪声。这种方法在处理模拟信号和低电平数字信号时特别有用，因为这些信号更容易受到地噪声的影响。然而，单点接地确实会增加PCB布局的复杂性，尤其是在高密度的集成电路中。 另一方面，大面积铺地可以提供良好的电磁屏蔽效果，有助于减少外部噪声对PCB上敏感电路的影响。此外，大面积铺地还可以降低PCB上的接地阻抗，从而减少地线电阻引起的噪声。在处理高频信号或需要高电流承载能力的应用中，大面积铺地尤为重要。 在实际设计中，可以根据具体需求和条件选择适当的接地策略。例如，可以将模拟地和数字地分开，并通过单点接地连接到公共地；同时，在PCB的外层使用大面积铺地，以提供电磁屏蔽和降低接地阻抗。这样的混合策略可以结合单点接地和大面积铺地的优点，从而获得最佳的设计效果。 简单说就是：高频走大面积地，低频音频走单点地 想要地线阻抗为零是几乎不可能的，就算接近零也要看与扰动源的阻抗的比例是否足够小；总之： 1、功率地（低阻地）与信号地要注意电流走向，不要形成相互干扰，至少不应该产生正反馈 2、数字地与模拟信号要分开走到电源滤波地中点，不要让数字电路的脉冲干扰串入模拟地 3、环地不光要看“直流”环地，也要看“交流”环地，电路分析中的交流分析中，电源是看为对地“短路”的，另外电源退耦电容也是交流短路（通交隔直）的 4、双电流的滤波电容接地更地一点接地，因为整流滤波是低阻脉动干扰源，脉动电流往往是安倍级，1毫欧的线路都能产生毫伏以上的脉动信号，百倍放大后应该都能听得到声音的了。 大面积要的是等电位面的概念，用于高频，小信号等小电流敏感区。等电位面严格说也应一点接地。一点接地要的是断掉地环流。 地线环路干扰现象 在PCB设计中，高频信号和低频信号的回流通路确实有所不同。 对于低频信号，其回流路径通常选择阻抗最低的路径。这是因为低频信号的频率相对较低，其对应的波长较长，因此信号的反射较小，主要考虑的是路径的电阻最小，以保证最小的能量损失。 而对于高频信号，其回流路径通常选择感抗最低的路径。随着信号频率的提高，信号的反射效应变得更加显著，此时需要考虑的是路径的电感和电容效应，使得信号能够在路径上顺利传输，因此高频信号的回流路径更倾向于选择感抗最低的路径。","tags":["机器之脉络","HiFi"],"categories":["理论"]},{"title":"雷池防火墙安装","path":"/2024/02/29/161936/","content":"在线安装（推荐） 如果服务器可以访问互联网环境，推荐使用该方式 复制以下命令执行，即可完成安装 1bash -c &quot;$(curl -fsSLk https://waf-ce.chaitin.cn/release/latest/setup.sh)&quot; 如果需要使用华为云加速，可使用 1CDN=1 bash -c &quot;$(curl -fsSLk https://waf-ce.chaitin.cn/release/latest/setup.sh)&quot; 如果需要安装最新版本流式检测模式，可使用 1STREAM=1 bash -c &quot;$(curl -fsSLk https://waf-ce.chaitin.cn/release/latest/setup.sh)&quot; 登录 浏览器打开后台管理页面 https://&lt;waf-ip&gt;:9443。 根据界面提示，使用 支持 TOTP 的认证软件或者小程序 扫描二维码，然后输入动态口令登录：","tags":["服务器","防火墙"],"categories":["工具"]},{"title":"关于博客分类与标签","path":"/2024/02/28/173516/","content":"寻找分类的方案 《IT人员如何管理知识》这篇文章中把知识分为： 业务领域（决策层、管理层、执行层） 行业（IT、金融、媒体、支付、制造、零售） 技术细分（理论、方法论、解决方案、应用技术、工具） 有的人涉及领域很广，所以直接搬图书馆的分类，参考《中国图书馆分类法》： A 马克思列宁主义、毛泽东思想、邓小平理论 B 哲学、宗教 C 社会科学总论 … T 工业技术 U 交通运输 V 航空、航天 X 环境科学、安全科学 《如何规划blog的标签（tag）和分类》中为博客分类，作者自己的评价是“这样粗线条的划分的好处是分类会比较稳定，毕竟更新分类比起添加tag要麻烦很多”： 1.域.业务领域 2.术.解决方案 3.技.技术研究 4.阵.技术应用 5.法.手段方法 6.理.理论学习 7.器.工具使用 A.杂.杂七杂八 我的 🔗参考链接 Category： 理论：理论知识技能，技术 应用：应用笔记，实操 折腾：折腾折腾折腾折腾！(其实属于应用，但就是玩！) 方法：方法论（经验谈），如工程方法 工具：针对具体工具的介绍、使用方法、分析适用场景等；使用工具如何如何解决具体问题，应该放在「应用」里 作品：自己的作品（成品）、个人项目日志等 杂谈：生活碎碎念 自然科学：物理，化学，数学 其他：没法分类的东西 Tags 根据需要灵活添加，但应避免添加太细的tag以避免膨胀，例如： 细分领域：机器之脉络(硬件),机器之魂魄(嵌入式软件,机器学习，算法等),机器之骨骼(结构), 形式：日志 具体内容：个人作品、方法论、随笔 语言：python C C# Java Html micropython 微信小程序 IDE：Arduino CUBEIDE Vscode 自然科学：代数 几何 概率 黑洞 白矮星 四维空间… IC OR IDE : STM32 ESP32 ESP8266 C51 树莓派 RK3399 野火开发版 MIQI 模组：ws2812b 系统：Linux Windows macOS openwrt Docker termux 游戏：MC 博客：hexo 主题 魔改 折腾系类：黑苹果，整服务器，termux","tags":["方法论"],"categories":["方法"]},{"title":"运算放大器","path":"/2024/02/27/144003/","content":"运算放大器(OP AMP) 比例放大电路 两大重要原则贯穿始终，“虚短”与“虚断”。“虚短”的意思是正端和负端接近短路，即V+=V−V+=V-V+=V−,看起来像“短路”;“虚断”的意思是流入正端及负端的电流接近于零，即I+=I−=0I+=I-=0I+=I−=0,看起来像断路（因为输入阻抗无穷大）。 有公式： Vout=−R2R1×VinV_{out} = - \\frac{R_2}{R_1} \\times V_{in} Vout​=−R1​R2​​×Vin​ −-−代表输出和输入相位相差180°。 因为Vout与Vin成线性的比例关系，因此这个典型放大电路被称为比例放大电路。 关于R1,R2及R3的选值： R1,R2及R3应该在K级，不宜达到M级； R3应该等于或近似于R1与R2的并联，以消除偏置电流的影响。 差分放大电路 有公式： Vout=R2R1×(V2−V1)V_{out} = \\frac{R_2}{R_1} \\times (V_{2}-V_1) Vout​=R1​R2​​×(V2​−V1​) 同相放大电路 输出和输入保持相同的相位。理想的运放具有输入阻抗无穷大，输出阻抗无穷小的特点，同相放大电路保持了运放的这种特性。 有公式： Vout=(1+R2R1)×VinV_{out} = (1+\\frac{R_2}{R_1}) \\times V_{in} Vout​=(1+R1​R2​​)×Vin​ 运算放大器内部电路 运算放大器是一种高电压增益、高输入电阻和低输出电阻的多级直接耦合放大电路。它的内部构造通常包括输入级、中间级和输出级。 输入级 输入级的主要功能是接收并放大输入信号。对于常见的运算放大器，例如741运放，输入级通常包括差动放大器和达林顿放大器。 中间级 中间级的主要作用是将信号从微弱的电平放大到足够大的电平时，再经过输出级的负载电阻，将放大的信号传递给负载，以供使用。 输出级 输出级的主要功能是将放大后的信号传递给负载。为了防止因受输出引脚上连接的电阻等的负载的影响使运算放大器的特性发生变化，通常会作为缓冲器连接输出段。 运算放大器工作原理 运算放大器的工作原理主要是通过放大输入信号的微小差异来实现。具体来说，当输入端之一接受到更高电压时，运算放大器会增大，随后产生相应的输出转变。 例如，对于741运放，当输入端的电位发生改变时，由于电源电压的变化，使得输入端的电位发生改变。当电源电压为0V或5v时，输入端的电位为-2.5V，此时如果采用分压方式，那么，通过中间的反馈电阻R，使R上的电流变化，从而引起反馈网络的通断，进而影响整个放大器的频率响应。 运算放大器的性能指标 运算放大器的性能指标主要包括以下几个方面： 静态工作点：指无外界干扰，且温度恒定的情况下，放大器稳定工作的工作点。 增益：是指单位增益下，对被处理信号的线性度。 失调：是指在某一频率范围内，某上所加激励与该频率下的被处理量之比的值。 频响：是指放大器在给定激励条件下，对指定波形进行不失真重放的频带宽度。 运算放大器的分类 按照结构形式，运算放大器可以分为单片式、双极型及多极型。其中，单片式具有体积小、重量轻，价格低的特点；双极型利用双极性的互补作用来改善共模抑制比，提高抗干扰能力，同时还可以减小自身噪声；多芯片集成设计可以有效地降低系统的成本，而且，多芯片集成的设计，可以使系统更加紧凑，有利于散热。","tags":["机器之脉络"],"categories":["理论"]},{"title":"肖特基二极管","path":"/2024/02/20/000329/","content":"肖特基二极管技术详解 什么是肖特基二极管？ 肖特基二极管是一种利用金属-半导体（M-S）接触原理制成的半导体器件。它与传统的PN结二极管不同，具有较低的正向导通压降和快速的切换速度，因此在许多高频、高效率的应用中表现出色。 肖特基二极管的定义和内部结构 定义 肖特基二极管是一种基于金属-半导体接触的半导体器件，具有优异的开关性能和高频特性。 内部结构 肖特基二管的内部结构主要包括一个N型半导体和一个金属层。N型半导体提供大量的电子，而金属层则吸引这些电子，形成一个内建电场。 肖特基二极管的等效电路和工作原理 等效电路 在电路中，肖特基二极管通常被表示为一个具有恒定电压降（Vf）的开关元件。这个电压降远低于传统PN结二极管的0.7V，使得肖特基二极管在高频整流中具有更高的效率。 工作原理 无偏置状态 在没有外加电压的情况下，N型半导体和金属层之间存在一个内建电场，阻止电流的流动。 正向偏置 当在肖特基二极管两端施加正向电压时，内建电场减弱，电子获得能量并跨越势垒，导致电流的流动。 反向偏置 在反向偏置条件下，内建电场增强，势垒高度增加，从而阻止电流的流动。 肖特基二极管的VI特性和优缺点 VI特性 肖特基二极管的VI特性由其内部的肖特基势垒决定。当外加电压小于阈值电压（Vf）时，二极管处于截止状态，电流很小。当电压大于Vf时，二极管开始导电，电流随电压线性增加。 优点 低正向导通压降：肖特基二极管的Vf较低，有利于提高电路的整体效率。 快速恢复时间：肖特基二极管具有快速的切换速度，适合于高频应用。 低结电容：较小的结电容有助于减少噪声和干扰。 高电流密度：肖特基二极管能够承受较高的电流密度，适用于功率密集型的应用。 噪音更小：由于其特殊的结构和工作原理，肖特基二极管的噪音水平相对较低。 性能更好：综合以上优点，肖特基二极管在许多应用中表现出优异的性能。 缺点 较高反向电流：在高温或高反向电压下，肖特基二极管可能产生较高的反向漏电流。 较低最大反向电压：相比于传统PN结二极管，肖特基二极管的最大反向击穿电压较低。 肖特基二极管的特别之处及应用领域 肖特基二极管的特别之处在于其优异的开关性能和高频特性。这使得它在射频混频器、检波二极管、功率整流器、电源或电路电压钳位/削波电路、反向电流和放电保护、采样保持电路以及太阳能电池等领域有着广泛的应用。 特别之处 高效率：由于低正向导通压降，肖特基二极管在高频整流中具有更高的效率。 快速响应：快速的切换速度使得肖特基二极管能够应对高速变化的信号。 应用领域 射频混频器和检波二极管：在射频通信中，肖特基二极管用于实现信号的混频和检波功能。 功率整流器：由于其高电流承受能力，肖特基二极管常用于功率整流器中，将交流电转换为直流电。 电源或电路电压钳位/削波电路：肖特基二极管用于限制电路中的电压峰值，保护敏感元件免受损伤。 反向电流和放电保护：在电池等储能设备中，肖特基二极管用于防止反向电流造成的损坏。 采样保持电路：在模拟-数字转换器中，肖特基二极管用于维持输入信号的稳定状态。 太阳能电池：肖特基二极管用于太阳能电池的旁路电路，提高电池的输出性能。","tags":["机器之脉络"],"categories":["理论"]},{"title":"初识k8s","path":"/2024/02/19/171428/","content":"Kubernetes能做什么 Kubernetes（简称K8S）是一款开源的容器编排平台，主要用于自动化部署、管理和扩展容器化应用。以下是Kubernetes的主要功能和用途： 自动化部署：Kubernetes可以自动化部署容器化应用，包括应用的创建、启动、停止和重启等操作。 负载均衡：Kubernetes可以为容器提供负载均衡服务，使得不同容器之间的请求能够均匀分配，提高应用的整体性能。 扩展和缩减：Kubernetes可以根据应用的需求自动扩展或缩减容器的数量，以满足应用的不同负载需求。 故障恢复：当某个容器出现故障时，Kubernetes可以自动替换这个容器，保证应用的高可用性。 服务发现：Kubernetes可以为每个容器提供唯一的网络标识，使得其他容器可以通过这个标识找到并访问该容器。 存储管理：Kubernetes支持多种类型的存储系统，可以为容器提供持久化的存储服务。 安全保障：Kubernetes提供了丰富的安全策略和工具，可以帮助开发者更好地保护他们的应用。 批处理：除了服务外，Kubernetes还可以管理批处理和CI（持续集成）工作负载，如有需要，可以替换失败的容器。 水平扩缩：使用简单的命令、用户界面或根据CPU使用率自动对你的应用进行扩缩。 IPv4/IPv6双栈：为Pod（容器组）和Service（服务）分配IPv4和IPv6地址。 为可扩展性设计：在不改变上游源代码的情况下为你的Kubernetes集群添加功能。 总的来说，Kubernetes提供了一种高效、灵活的方式来管理容器化应用，使得开发者可以更加专注于应用本身，而不需要关心基础设施的问题。 他是如何实现多个硬件共同运行一个程序的 Kubernetes通过以下方式实现多个硬件共同运行一个程序： Pods：在Kubernetes中，最小的工作单位是Pod，一个Pod可以包含一个或多个容器，这些容器共享存储、网络和其他资源。这意味着，在一个硬件设备（Node）上可以运行多个Pod，每个Pod都可以是一个独立的应用程序或服务。 ReplicaSets：为了确保高可用性，Kubernetes可以使用ReplicaSet来复制Pod的实例，并在多个硬件设备（Node）上运行这些实例。这样即使某个硬件设备发生故障，也不会影响到整个应用的运行。 Services：Kubernetes中的Service是一种抽象，它可以暴露一组Pod的接口，并将请求路由到这些Pod。这意味着，无论Pod在哪个硬件设备上运行，只要它们属于同一个Service，外部就可以通过这个Service来访问它们。 Storage Management：Kubernetes还提供了存储管理功能，可以将数据持久化存储在云存储或其他存储系统中，这样即使硬件设备发生故障，数据也不会丢失。 Load Balancing：Kubernetes还内置了负载均衡功能，可以将请求分发给多个Pod，从而充分利用硬件资源，提高应用性能。 以上就是Kubernetes如何实现多个硬件共同运行一个程序的基本原理。具体实现过程可能会因具体的应用场景和需求有所不同。 Kubernetes 架构 Kubernetes 最初源于谷歌内部的 Borg，提供了面向应用的容器集群部署和管理系统。Kubernetes 的目标旨在消除编排物理 / 虚拟计算，网络和存储基础设施的负担，并使应用程序运营商和开发人员完全将重点放在以容器为中心的原语上进行自助运营。Kubernetes 也提供稳定、兼容的基础（平台），用于构建定制化的 workflows 和更高级的自动化任务。 Kubernetes 具备完善的集群管理能力，包括多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务注册和服务发现机制、内建负载均衡器、故障发现和自我修复能力、服务滚动升级和在线扩容、可扩展的资源自动调度机制、多粒度的资源配额管理能力。Kubernetes 还提供完善的管理工具，涵盖开发、部署测试、运维监控等各个环节。 Kubernetes 借鉴了 Borg 的设计理念，比如 Pod、Service、Label 和单 Pod 单 IP 等。Kubernetes 的整体架构跟 Borg 非常像。 分层架构 核心层：Kubernetes 最核心的功能，对外提供 API 构建高层的应用，对内提供插件式应用执行环境 应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS 解析等）、Service Mesh（部分位于应用层） 管理层：系统度量（如基础设施、容器和网络的度量），自动化（如自动扩展、动态 Provision 等）以及策略管理（RBAC、Quota、PSP、NetworkPolicy 等）、Service Mesh（部分位于管理层） 接口层：kubectl 命令行工具、客户端 SDK 以及集群联邦 生态系统：在接口层之上的庞大容器集群管理调度的生态系统，可以划分为两个范畴 Kubernetes 外部：日志、监控、配置管理、CI/CD、Workflow、FaaS、OTS 应用、ChatOps、GitOps、SecOps 等 Kubernetes 内部：CRI、CNI、CSI、镜像仓库、Cloud Provider、集群自身的配置和管理等 参考链接 架构 部署","tags":["k8s","服务器"],"categories":["应用"]},{"title":"ESP8266 arduino http OTA","path":"/2024/01/15/191024/","content":"ESP8266不仅可以通过IDE进行OTA，也可以通过具体网址进行OTA 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;ESP8266httpUpdate.h&gt;// ESP8266HTTPUpdateServer httpUpdater;WiFiClient UpdateClient;/** * 功能：联网下载固件文件OTA * @param NONE * @return NONE * @example https_OTA(); * @note NONE * @link https://zhuanlan.zhihu.com/p/435855807 * @history * V0.0.1 2024-01-05 初始版本，未能实现功能 * V0.0.1 2024-01-08 更新变量 UpdateClient，成功升级 * */void https_OTA() &#123; while (1) &#123; // 设置回调函数以获取下载进度 ESPhttpUpdate.onProgress([](int progress, int total) &#123; Serial.printf(&quot;Progress: %d%% &quot;, (progress * 100) / total); strip.setPixelColor(((progress / (total / 100))) - 1, (progress / (total / 100)) / 100 * 255 * brightness / 100, (255 - (progress / (total / 100)) / 100 * 255) * brightness / 100, (255 - (progress / (total / 100)) / 100 * 255) * brightness / 100); strip.show(); &#125;); t_httpUpdate_return ret = ESPhttpUpdate.update(UpdateClient, &quot;http://xxxxxxxx/beta_0_0_1.bin&quot;); // t_httpUpdate_return ESP8266HTTPUpdate::handleUpdate(&quot;http://hp-l.gitee.io/electronic_calendar_main/IoT/electronic.bin&quot;); switch (ret) &#123; case HTTP_UPDATE_OK: Serial.println(&quot;Firmware updated successfully&quot;); break; case HTTP_UPDATE_FAILED: Serial.println(&quot;Firmware update failed&quot;); break; case HTTP_UPDATE_NO_UPDATES: Serial.println(&quot;No firmware updates available&quot;); break; default: Serial.printf(&quot;Firmware update error %d &quot;, ret); break; &#125; &#125;&#125;","tags":["ESP8266","arduino","OTA"],"categories":["应用"]},{"title":"ESP8266 arduino OTA","path":"/2024/01/15/190246/","content":"联网成功后可以通过IDE进行OTA升级，代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;ArduinoOTA.h&gt;/** * 功能：OTA初始化 * @param NONE * @return NONE * @example arduino_8266_OTA(); * @note NONE * @history * V0.0.1 2024-01-05 初始版本 * */void arduino_8266_OTA() &#123; // OTA设置并启动 // ArduinoOTA.setHostname(&quot;ESP8266&quot;); // ArduinoOTA.setPassword(&quot;12345678&quot;); ArduinoOTA.begin(); Serial.println(&quot;OTA ready&quot;); ArduinoOTA.onStart([]() &#123; String type; if (ArduinoOTA.getCommand() == U_FLASH) &#123; type = &quot;sketch&quot;; &#125; else &#123; // U_FS type = &quot;filesystem&quot;; &#125; Serial.println(&quot;Start updating &quot; + type); &#125;); ArduinoOTA.onProgress([](unsigned int progress, unsigned int total) &#123; Serial.printf(&quot;Progress: %u%%\\r&quot;, (progress / (total / 100))); // strip.setPixelColor((progress / (total / 100)) - 1, 1, 0, 1); strip.setPixelColor(((progress / (total / 100))) - 1, (progress / (total / 100)) / 100 * 255 * brightness / 100, (255 - (progress / (total / 100)) / 100 * 255) * brightness / 100, (255 - (progress / (total / 100)) / 100 * 255) * brightness / 100); strip.show(); &#125;); ArduinoOTA.onError([](ota_error_t error) &#123; Serial.printf(&quot;OTA更新发生错误[%u]: &quot;, error); if (error == OTA_AUTH_ERROR) &#123; Serial.println(&quot;认证失败&quot;); &#125; else if (error == OTA_BEGIN_ERROR) &#123; Serial.println(&quot;开始失败&quot;); &#125; else if (error == OTA_CONNECT_ERROR) &#123; Serial.println(&quot;连接失败&quot;); &#125; else if (error == OTA_RECEIVE_ERROR) &#123; Serial.println(&quot;接收失败&quot;); &#125; else if (error == OTA_END_ERROR) &#123; Serial.println(&quot;结束失败&quot;); &#125; // 复位设备 ESP.restart(); &#125;); ArduinoOTA.onEnd([]() &#123; Serial.println(&quot;OTA更新结束&quot;); strip.clear(); // 关闭所有灯 &#125;);&#125; 以上代码中brightness是led的亮度，范围是1~100，setPixelColor可以参考点亮ws2812的文章","tags":["ESP8266","arduino","OTA"],"categories":["应用"]},{"title":"ESP8266 arduino 无线联网","path":"/2024/01/15/184136/","content":"ESP8266 WiFi 联网函数 WiFi部分联网 12345678910111213141516171819202122232425262728293031323334353637#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266mDNS.h&gt;const char *ssid = &quot;wifi_ssid&quot;;const char *password = &quot;wifi_password&quot;;/** * 功能：Wifi连接 * @param NONE * @return NONE * @example connectWifi(); * @note NONE * @history * V0.0.1 2024-01-05 初始版本 * */void connectWifi() &#123; // 开始连接wifi WiFi.begin(ssid, password); int num = 0; // 等待WiFi连接,连接成功打印IP while (WiFi.status() != WL_CONNECTED) &#123; Serial.print(&quot;.&quot;); delay(500); num = num + 1; if (num &gt; 9) &#123; break; &#125; strip.clear(); // 关闭所有灯 &#125; Serial.println(&quot;&quot;); Serial.println(&quot;WiFi Connected!&quot;); Serial.print(&quot;IP address:\\t&quot;); Serial.println(WiFi.localIP()); if (WiFi.status() != WL_CONNECTED) &#123; connectsoftAP(); // 无法连接 WiFi 打开 AP 模式 &#125;&#125; AP 部分 123456789101112131415161718192021222324/** * 功能：AP连接 * @param NONE * @return NONE * @example connectsoftAP(); * @note NONE * @history * V0.0.1 2024-01-05 初始版本 * */void connectsoftAP() &#123; // 设置内网 IPAddress softLocal(192, 168, 128, 1); // 1 设置内网WIFI IP地址 IPAddress softGateway(192, 168, 128, 1); IPAddress softSubnet(255, 255, 255, 0); WiFi.softAPConfig(softLocal, softGateway, softSubnet); String apName = (&quot;ESP8266_&quot; + (String)ESP.getChipId()); // 2 设置WIFI名称 const char* softAPName = apName.c_str(); WiFi.softAP(softAPName, &quot;adminadmin&quot;); // 3创建wifi 名称 +密码 adminadmin IPAddress myIP = WiFi.softAPIP(); // 4输出创建的WIFI IP地址 Serial.print(&quot;AP IP address: &quot;); Serial.println(WiFi.localIP()); // ESP_IP = WiFi.localIP().toString(); Serial.print(&quot;softAPName: &quot;); // 5输出WIFI 名称 Serial.println(apName);&#125;","tags":["ESP8266","arduino","C++"],"categories":["应用"]},{"title":"arduino ESP8266点亮ws2812b","path":"/2023/12/28/155718/","content":"软件环境配置 在如图位置输入开发版管理地址 1https://arduino.esp8266.com/stable/package_esp8266com_index.json 硬件连接 DIN 接 Nodemcu PIN D7 代码 彩虹灯 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;Adafruit_NeoPixel.h&gt;#define PIN D7 // pin on which the NeoPixels are connected // How many NeoPixels are attached to the Arduino?#define NUMPIXELS 8 //流水灯数量 // When we setup the NeoPixel library, we tell it how many pixels, and which pin to use to send signals.Adafruit_NeoPixel pixels = Adafruit_NeoPixel(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800); // This is the &#x27;setup&#x27; function. It runs once, when the Arduino is powered on or reset.void setup()&#123; pixels.begin(); // This initializes the NeoPixel library.&#125; // This is the &#x27;loop&#x27; function. It runs over and over again, as long as the Arduino has powervoid loop()&#123; rainbow(10); // 彩虹灯&#125;void rainbow(int wait) &#123; // Hue of first pixel runs 5 complete loops through the color wheel. // Color wheel has a range of 65536 but it&#x27;s OK if we roll over, so // just count from 0 to 5*65536. Adding 256 to firstPixelHue each time // means we&#x27;ll make 5*65536/256 = 1280 passes through this loop: for(long firstPixelHue = 0; firstPixelHue &lt; 5*65536; firstPixelHue += 256) &#123; // strip.rainbow() can take a single argument (first pixel hue) or // optionally a few extras: number of rainbow repetitions (default 1), // saturation and value (brightness) (both 0-255, similar to the // ColorHSV() function, default 255), and a true/false flag for whether // to apply gamma correction to provide &#x27;truer&#x27; colors (default true). pixels.rainbow(firstPixelHue); // Above line is equivalent to: // strip.rainbow(firstPixelHue, 1, 255, 255, true); pixels.show(); // Update strip with new contents delay(wait); // Pause for a moment &#125;&#125; 参考链接 https://www.sohu.com/a/153985016_796852","tags":["机器之魂魄","ESP8266","arduino","ws2812b"],"categories":["应用"]},{"title":"如何加快hexo站点访问速度","path":"/2023/12/27/165200/","content":"安装 1npm install hexo-neat --save 博客根目录文件_config.yml文末添加如下 123456789101112131415161718# hexo-neat# md博文压缩neat_enable: true# 压缩html（ejs，swig等也属于html格式片段）neat_html: enable: true exclude:# 压缩css neat_css: enable: true exclude:# 压缩jsneat_js: enable: true mangle: true #打印日志 output: compress: exclude: #排除文件 &lt; (￣ˇ￣)/","tags":["hexo"],"categories":["应用"]},{"title":"记录一次MIQI RK3288 board折腾","path":"/2023/12/19/124059/","content":"相关资料 链接 下载镜像 链接 烧录 步骤123 解决问题 无法更新 解决16.04无法升级软件问题，清空 /etc/apt/apt.conf 1echo &gt; /etc/apt/apt.conf 清空后成功升级，可是换源后又出现无法升级的问题 上网查询相关信息说需要安装apt-transport-https，但是我这里提示找不到相关包， 然后执行命令: 12cd /usr/lib/apt/methodsln -s http https 来骗一下apt，让它把http当成https。。。 成功update HDMI无法启动桌面 漫长更新后reboot，结果桌面无法启动。。。 再次上网求助，尝试过查找HDMI设备，等办法无用，最后想干脆远程桌面于是安装了x11vnc，reboot后HDMI奇迹般能使用了 编辑文件/etc/X11/xorg.conf 123456Section &quot;Monitor&quot; Identifier &quot;Monitor0&quot; VendorName &quot;Monitor Vendor&quot; ModelName &quot;Monitor Model&quot; Modeline &quot;1280x1024_60.00&quot; 108.88 1280 1360 1496 1712 1024 1025 1028 1060 -HSync +VsyncEndSection 1sudo apt-get install x11vnc","tags":["linux","MIQI","KR3288"],"categories":["应用"]},{"title":"平衡三进制","path":"/2023/12/12/141228/","content":"范例 这是一个不太标准的计数体系。 我们使用Z表示-1，使用1、0、Z表示三进制 举个例子： 123456789100 01 12 1Z3 104 115 1ZZ6 1Z07 1Z18 10Z9 100 负数如下，只需倒过来即可 12345-1 Z-2 Z1-3 Z0-4 ZZ-5 Z11 过程 平衡三进制转换法：给定数x =&gt; 标准三进制 =&gt; 如遇到2转为Z，同时下一位加上1，遇到3换为0，下一位加上1（如遇2=&gt;Z、3=&gt;0，左边一位+1） 一个例子 851 转换为 平衡三进制 $ 851_{(10)} = 1011112_{(3)} $ 2 =&gt; Z + 1 11ZZZZZ 测试代码 123456789101112131415161718192021222324252627def decimal_to_balanced_ternary(decimal_num): &quot;&quot;&quot; 将10进制数转换为平衡三进制数 &quot;&quot;&quot; if decimal_num == 0: return &#x27;0&#x27; # 定义三进制数字符号 digits = [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;Z&#x27;] balanced_ternary_num = &#x27;&#x27; while decimal_num != 0: remainder = decimal_num % 3 decimal_num //= 3 if remainder == 2: decimal_num += 1 balanced_ternary_num = digits[remainder] + balanced_ternary_num return balanced_ternary_num# 测试代码print(decimal_to_balanced_ternary(10)) # 输出：&#x27;101&#x27;print(decimal_to_balanced_ternary(65)) # 输出：&#x27;1Z11Z&#x27;print(decimal_to_balanced_ternary(0)) # 输出：&#x27;0&#x27;print(decimal_to_balanced_ternary(851)) # 输出：&#x27;11ZZZZZ&#x27;","tags":["进制"],"categories":["理论"]},{"title":"M710Q解锁高级选项","path":"/2023/11/22/011625/","content":"参考链接 联想M710Q解锁高级选项 M710Q 别再用电阻给风扇降速了 教你用bios给风扇调速 解锁高级菜单 降压超频 实施步骤 先从官网下载 BIOS http://www.smxdiy.com/thread-1299-1-1.html 安装时可以选择解压到本地 解压到本地后找到 ROM 文件，使用UEFI Tool，查找Hide CRB Items GitHub - LongSoft/UEFITool: UEFI firmware image viewer and editor 双击下方的Message定位到包含块，右键Extract body导出文件 txt。 打开文件搜索Hide CRB Items，我的是0xFE3 每台机可能有所不同 下载efi 文件，修改文件名为Bootx64.efi文件放到 fat32 格式的 U 盘下，路径为/EFI/boot/Bootx64.efi，重启计算机进入引导程序，输入以下命令 文件可以从视频博主的 QQ 群下载，一可以在本站下载 setup_var.efi 命令说明：setup_var 地址 值 12setup_var 0xFE3 0reboot 重启会发现有一些变化","tags":["黑苹果","macOS"],"categories":["折腾"]},{"title":"DNS | github访问不了解决方法","path":"/2023/11/17/034404/","content":"DNS | github访问不了解决方法 常见速度慢的原因有以下几种可能： 网络本来速度慢(不太可能) DNS解析配置导致 hosts域名ip解析配置导致 网络带宽过大(不常见) 将一下代码追加到host文件中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# github start# Github Hosts# Update 20210312140.82.112.3 github.com140.82.112.10 nodeload.github.com140.82.114.6 api.github.com13.229.189.0 codeload.github.com185.199.110.133 raw.github.com185.199.110.153 training.github.com185.199.110.153 assets-cdn.github.com185.199.110.153 documentcloud.github.com185.199.110.154 help.github.com185.199.110.153 githubstatus.com199.232.69.194 github.global.ssl.fastly.net185.199.110.133 raw.githubusercontent.com185.199.110.133 cloud.githubusercontent.com185.199.110.133 gist.githubusercontent.com185.199.110.133 marketplace-screenshots.githubusercontent.com185.199.110.133 repository-images.githubusercontent.com185.199.110.133 user-images.githubusercontent.com185.199.110.133 desktop.githubusercontent.com185.199.110.133 avatars.githubusercontent.com185.199.110.133 avatars0.githubusercontent.com185.199.110.133 avatars1.githubusercontent.com185.199.110.133 avatars2.githubusercontent.com185.199.110.133 avatars3.githubusercontent.com185.199.110.133 avatars4.githubusercontent.com185.199.110.133 avatars5.githubusercontent.com185.199.110.133 avatars6.githubusercontent.com185.199.110.133 avatars7.githubusercontent.com185.199.110.133 avatars8.githubusercontent.com# End of the section#192.30.255.112 github.com git #185.31.16.184 github.global.ssl.fastly.net#140.82.114.4 github.com#140.82.114.4 gist.github.com#185.199.108.153 assets-cdn.github.com#151.101.64.133 raw.githubusercontent.com#151.101.108.133 gist.githubusercontent.com#151.101.108.133 cloud.githubusercontent.com#151.101.108.133 camo.githubusercontent.com#151.101.108.133 avatars0.githubusercontent.com#151.101.108.133 avatars1.githubusercontent.com#151.101.108.133 avatars2.githubusercontent.com#151.101.108.133 avatars3.githubusercontent.com#151.101.108.133 avatars4.githubusercontent.com#151.101.108.133 avatars5.githubusercontent.com#151.101.108.133 avatars6.githubusercontent.com#151.101.108.133 avatars7.githubusercontent.com#151.101.108.133 avatars8.githubusercontent.com","tags":["方法论"],"categories":["应用"]},{"title":"M710Q黑苹果折腾记录","path":"/2023/11/14/153249/","content":"M710Q黑苹果折腾记录 本人小白，23 年 9 月才有了第一台黑苹果，纯属折腾玩，想稳定以及更深入了解与制作黑苹果 EFI 可以参考黑果小兵、国光黑苹果教程，参考有链接。 上图 黑苹果型号 主板 ：联想 M710Q CPU ： i3-7100t 显卡 ： Intel HD Graphics 630 无线网卡 ： AX210（无法实现隔空投送） 声卡 ： ALC294（layout-id 21） 以太网 ：免驱 参考 关于资源搜索参考黑果小兵的一段话 建议大家使用yandex搜索引擎、github先搜索下有没有自己的机型，型号一样，机型配置有差异可以忽略，使用你的机器型号+clover、型号+EFI、型号+mac、型号+Hackintosh等进行搜索。例如我最近更新了 elitebook840g3、840g4等几个机型的 EFI，就可以使用840g3+clover 840g3+EFI 等关键词进行搜索。 在github能搜索出较多同一平台单配置和自己需求不太一样的资源，理论上一部分是能够开机的，可以后期在维护相关的驱动。 另外下面两个大佬链接值得一看 黑果配置 黑果小兵的部落阁 驱动制作 主页 - 国光的黑苹果安装教程：手把手教你配置 OpenCore (sqlsec.com) 折腾过程 BIOS 设置 可以参考国光黑苹果教程完成 BIOS设置 - 国光的黑苹果安装教程：手把手教你配置 OpenCore (sqlsec.com) 制作启动盘 工具：balenaEthcher 获取镜像 本镜像取自于远景这个 349336500 老哥的帖子：https://bbs.pcbeta.com/viewthread-1948333-1-1.html 以下链接参考自国光的博客 1234567891011121314# 天翼云：macOS Ventura 13.1 (22C65)：https://cloud.189.cn/t/YZFzeqU3mmie (访问码:vhy3)macOS Ventura 13 (22A380)：https://cloud.189.cn/t/ZzQraemMz2Av (访问码:1xur)# 阿里云盘：macOS Ventura 13.4.1 (22F82)：https://www.aliyundrive.com/s/gDSytaiiVfamacOS Ventura 13.4 (22F66)：https://www.aliyundrive.com/s/LEvFAArLZ5ZmacOS Ventura 13.3 (22E252)：https://www.aliyundrive.com/s/atvncNVMJNcmacOS Ventura 13.2 (22D49)：https://www.aliyundrive.com/s/LL6inEwVUdMmacOS Ventura 13.1 (22C65)：https://www.aliyundrive.com/s/kydfwX7Y1oQmacOS Ventura 13 (22A380)：https://www.aliyundrive.com/s/BXoD7NgkMBz# 本站直连：https://pan.mediy.cn/%F0%9F%93%81Files/macOS/macOS%20Ventura%2013.4.1%20(22F82)（密码：mediy) 获取 EFI 方式 1：网上有较多博主分享的 EFI 文件，可以下载试一下能否顺利进入恢复界面 方式 2：一键生成 EFI 的 APP ： OC_Gen.app 我使用的是 OC_Gen-X工具，工具使用十分简单。 如果顺利进入恢复界面就可以安装 macOS 了（我的无线网卡和蓝牙驱动以及定制 USB 驱动都是在系统装好后添加进去的） 将这个原本EFI删除，替换制作好的EFI文件，开机进入启动盘选择Macos install ，剩下的步骤就是正常装机了。 我使用的EFI文件可以使用邮箱私信我，通过邮件分享（邮箱地址在本站关于页面最下面）。","tags":["黑苹果","macOS"],"categories":["折腾"]},{"title":"SiYuan在docker中自动同步","path":"/2022/09/09/053446/","content":"2022.09.09 Fri 如何同步思源笔记 工具 SiYuan Note Docker syncthing 如何解决 思源笔记软件本体不能同步，网上有一些教程是通过Onedrive同步的，但是需要账号，使用云端资源，于是便想到可以在本地搭建文件同步的服务用于解决笔记同步问题。 于是我上网寻找，最后找到了syncting 开始搭建 思源笔记 提示：您可以更改“/your/workspace/part”。 思源的数据存储在“/your/workspace/part”中。 我们稍后会使用它。 1sudo docker run -v /your/workspace/part:/siyuan/workspace -p 6806:6806 -u 1000:1000 --restart=always b3log/siyuan --workspace=/siyuan/workspace/ 搭建 syncthing 你可以根据你的情况改变 “~/docker_softsoftware_date/st-sync” 的内容 1sudo docker run -d -p 8384:8384 -p 22000:22000 -v ~/docker_softsoftware_date/st-sync:/var/syncthing --restart=always syncthing/syncthing:latest Syncthing 设置. Windows or Linux 添加远程设备 复制设备 ID ​ 将设备 ID 粘贴到局域网上的其他设备中。 ​ Add folder ​ 在不同的终端设备添加共享文件夹 添加思源数据文件&quot;/your/workspace/part&quot; 另一台设备添加路径，就像这样： “E:\\usr\\siyuan\\Siyun” Android 操作很简单，基本和上面一样。下面是应用的截图。 ​","tags":["siyuan"],"categories":["折腾"]},{"title":"树莓派4B搭建java MC服务器","path":"/2022/06/08/120705/","content":"Java 安装 安装java 1234sudo apt updatesudo apt install default-jdksudo apt install openjdk-8-jdksudo apt install openjdk-11-jdk 选择默认java版本，跟换成11 1sudo update-alternatives --config java 服务器构建器下载及其安装 下载链接 所有版本 点击下载 或者： 1wget https://maven.minecraftforge.net/net/minecraftforge/forge/1.18.2-40.1.48/forge-1.18.2-40.1.48-installer.jar 安装 1java -jar forge-1.18.2-40.1.48-installer.jar -install 会弹出图形界面，安装完成 运行服务器 cd 到安装目录，linux运行 1./run.sh 配置eula.txt 1eula=true","tags":["树莓派","MC"],"categories":["应用"]},{"title":"MOS管(Mosfet)","path":"/2022/06/01/132405/","content":"三极管和 MOSFET 对比 三极管 三极管简称晶体管，分为 NPN 型和 PNP 型两种，是最重要的一种半导体器件。它用于放大作用和开关作用。 Mosfet 就是场效应管，是一种较新型的半导体器件。外形与普通晶体管相似，但两者的控制特性却截然不同。 Mos 相对三极管的优势 MOSFET 二极管 结论 驱动方式 电压驱动 电流驱动 MOSFET 更节能 热稳定性 多子参与导电 多子、少子参与导电 MOSFET 更稳定 压降 0V 无压降 0.3V MOSFET 更合适集成 原理对比 MOSFET 二极管 通过控制基极电流才能达到控制集电极电流或发射极电流的目 它的输出电流决定于输入端电压的大小，基本上不需要信号源提供电流。 MOSFET 概述 分类 --&gt; 原理（N 沟道增强型） --&gt; 电气特性 分类 按沟道： N 沟道 P 沟道 按栅极电压： 耗尽型：当栅极电压为零时漏源极之间就存在导电沟道。 增强型：有电压才导通 对于N沟道器件，栅极电压大于零(&lt;0)时才存在导电沟道。 对于P沟道器件，栅极电压小于零(&gt;0)时才存在导电沟道。 功率 MOSFET 主要是：N 沟道增强型。 几种分类及其图标 工作原理 图中各部分从上往下依次是： 栅极(Gate) 漏极(Drain) 源极(Source) 橘黄色：金属 黄色：氧化物 浅红色：P 掺杂 深红色：耗尽区(depletion region) 一下过程模拟栅极(Gate)加压 当栅极(Gate)未施加电压时(=0)，漏极(Drain)和源极(Source)是断开的，如1.jpg。 当栅极(Gate)施加电压且大于0(&gt;0)时，漏极(Drain)和源极(Source)是断开的，但是栅极金属层将聚集正电荷，如2.jpg。 当栅极(Gate)施加电压且大于V_TH(&gt;V_TH)时，漏极(Drain)和源极(Source)之间形成反型层(inversion layer)，反型层相当于N掺杂的半导体，因此漏极(Drain)和源极(Source)直接连通，因此MOSFET导电沟道形成，进入导通状态。如3.jpg。 输出特性 夹断区(cutoff mode) 线性区(linear mode) 饱和区(saturation mode) 具体情况如下","tags":["mosfet","机器之脉络"],"categories":["理论"]},{"title":"Hello World","path":"/2022/05/04/152534/","content":"Welcome to my Blog! Git git config命令预先配置好相关的用户信息 12git config --global user.name &quot;你的名字或昵称&quot;git config --global user.email &quot;你的邮箱&quot; 常用的命令 12345git branch -a #查看当前分支git checkout master #切换到想要操作的分支mastergit add . #将当前目录所有文件添加到git暂存区git commit -m $(date +%Y-%m-%d-%H:%M:%S) #提交并备注提交信息git push origin master #将本地提交推送到远程仓库想要的分支master Quick Start 安装的插件 网址转拼音插件 安装 1npm i hexo-permalink-pinyin --save 配置及使用 在根目录中的_config.yml中国添加 1234# 网站 文字转拼音permalink_pinyin: enable: true separator: &quot;_&quot; # default: &#x27;-&#x27; hexo-electric-clock 电子时钟插件 安装 1npm i hexo-electric-clock --save 配置及使用 不是主题的yml文件 12345678910111213141516171819202122232425262728electric_clock: priority: 5 enable: true enable_page: all layout: type: class name: sticky_layout index: 0 temple_html: &#x27; &lt;div class=&quot;card-widget card-clock&quot;&gt; &lt;!-- 挂载容器 --&gt; &lt;div class=&quot;card-glass&quot;&gt; &lt;div class=&quot;card-background&quot;&gt; &lt;div class=&quot;card-content&quot;&gt; &lt;div id=&quot;hexo_electric_clock&quot;&gt; &lt;img id=&quot;card-clock-loading&quot; src=&quot;https://cdn.jsdelivr.net/gh/Zfour/Butterfly-clock/clock/images/weather/loading.gif&quot; style=&quot;height: 120px; width: 100%;&quot; data-ll-status=&quot;loading&quot; class=&quot;entered loading&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&#x27; Chart动态图标插件 安装 1npm install hexo-tag-chart --save 配置及使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!--fontColor:数据颜色--&gt;&lt;!--padding:上下左右填充--&gt;&lt;!--suggestedMin:最小值--&gt;&#123;% p center logo large, Hello😜 %&#125;***&#123;% p center h1, 一个用JS开发的硬件工程师 😋 %&#125;&#123;% p center small, 雷达图看不到刷新刷新就好啦 %&#125;&#123;% chart 100% 300 %&#125;&#123; type: &#x27;radar&#x27;, data: &#123; labels: [&#x27;C&#x27;, &#x27;Python&#x27;, &#x27;HTML&#x27;, &#x27;micropython&#x27;, &#x27;ESP8266&#x27;, &#x27;ESP32&#x27;, &#x27;STM32&#x27;, &#x27;SCT15&#x27;, &#x27;微信小程序&#x27;], datasets: [&#123; label: &#x27;值&#x27;, backgroundColor: &#x27;#9400D377&#x27;, borderColor: &#x27;#9400D3&#x27;, data: [20, 50, 40, 80, 40, 80, 55, 55, 10], lineTension: 0.2, pointStyle: &#x27;rectRounded&#x27;, pointHoverBackgroundColor: &#x27;#FFFFFF&#x27; &#125;] &#125;, options: &#123; legend: &#123; labels: &#123; fontColor: &#x27;#9400D3&#x27;, &lt;!--数据颜色--&gt; fontSize: 12, FontFamily: &#x27;&#x27; &#125; &#125;, layout: &#123; padding: &#123; &lt;!--上下左右填充--&gt; left: 0, right: 0, top: 0, bottom: 0 &#125; &#125;, responsive: true, title: &#123; display: true, text: &#x27;My dataset&#x27; &#125;, scale: &#123; angleLines: &#123; display: true &#125;, ticks: &#123; suggestedMin: 0, &lt;!--最小值--&gt; suggestedMax: 80 &lt;!--最大值--&gt; &#125; &#125; &#125;&#125;&#123;% endchart %&#125; Hexo-neat插件优化提升访问效率 安装 1npm install hexo-neat --save 博客根目录文件_config.yml文末添加如下 123456789101112131415161718# hexo-neat# md博文压缩neat_enable: true# 压缩html（ejs，swig等也属于html格式片段）neat_html: enable: true exclude:# 压缩css neat_css: enable: true exclude:# 压缩jsneat_js: enable: true mangle: true #打印日志 output: compress: exclude: #排除文件","categories":["main"]},{"title":"基于树莓派4B的Openwrt系统Docker中安装Wordpress","path":"/2022/03/25/142619/","content":"确保OpenWrt安装了Docker 在命令行键入以下命令以完成安装 1234docker run -d --name mariadb -p 3306:3306 -e MARIADB_ROOT_PASSWORD=meimima \\-e MARIADB_DATABASE=wordpress \\--restart=always \\mariadb:latest 1234567docker run -d --name wordpress -p 8083:80 -e WORDPRESS_DB_PASSWORD=meimima \\-e WORDPRESS_DB_HOST=你的IP:3306 \\-e WORDPRESS_DB_USER=root \\-e WORDPRESS_DB_NAME=wordpress \\-e WORDPRESS_TABLE_PREFIX=wp_ \\--restart=always \\wordpress 安装完成后会有以下提示 根据提示完成用户名密码录入 修改上传文件限制 1docker exec -it wordpress /bin/bash 进入容器后 安装vim 12345678mv /etc/apt/sources.list /etc/apt/sources.list.bakcat &lt;&lt;EOF &gt;/etc/apt/sources.listdeb http://mirrors.ustc.edu.cn/debian stable main contrib non-freedeb http://mirrors.ustc.edu.cn/debian stable-updates main contrib non-freeEOFapt updateapt install vim 12cp /usr/local/etc/php/php.ini-production /usr/local/etc/php/php.inivim /usr/local/etc/php/php.ini 搜索以下关键字 123upload_max_filesize = 200M #文件大小限制post_max_size = 250M #post大小限制memory_limit = 500M #内存占用限制 重启docker 1docker restart wordpress","tags":["openwrt","Docker"],"categories":["应用"]},{"title":"smb文件共享设置","path":"/2022/03/23/223128/","content":"linux服务器设置文件夹共享 vim /etc/samba/smb.conf 12345678910111213141516[Quark-Doc] path=/home/pi/Documents/Quark-Doc # 注意：path的值为你要共享的文件夹名称，此处我选择了根目录 # 说明信息 comment = NAS Storage # 可以访问的用户 # valid users = pi,root # 可被其他人看到资源名称（非内容） browseable = yes # 可写 writable = yes public = yes # 新建文件的权限为 664 create mask = 0664 # 新建目录的权限为 775 directory mask = 0775 保存后重启服务 1sudo service smbd restart Window设置映射网络驱动器 输入服务器上的密码即可，我设置的是服务器root账户密码","tags":["linux","smb"],"categories":["应用"]},{"title":"基于树莓派4B的OpenWrt配置","path":"/2021/11/20/210049/","content":"基于树莓派 4B 的 OpenWrt 配置 制作这个 OpenWrt 的原因 想拥有一个高度自定义的路由器，于是网上一搜，大部分都是用 OpenWrt 做的，虽然费尽周折（官方烧进去后不知道怎么连通过 ssh 访问），最终找到一个非常不错的镜像文件，就是这个链接Link。可以到 Releases 里面去找相应的固件下载。 烧录镜像 烧录过程如下图 完成后将卡插入 tf 卡槽，启动树莓派 调试过程 无线部分 注意： 初次启动树莓派，频宽为 5GHz,一些年纪较大的电脑可能识别不了，要把频宽换成 2.4GHz。 启动前向不用插入网线！！！ 接口设置 最初有三个接口(因为我的修改过，所以 Lan 口会有些不一样) 点解 Lan 口右侧的修改，选择物理设置，去除eth0的勾，点击保存并应用。 点击返回至概况，点击添加新接口， 名称随便写，做个标记而已，协议选择DHCP客户端，勾选eth0，点击保存并应用。 防火墙设置 点击防火墙设置，改变以下选择项，框内全部选择接受！！！点击保存并应用。 进入 Wan 口防火墙，修改以下值，退出时点击保存并应用。 切换到转发端口页面，有如下几个接口，我们需要添加两条规则 ip 上级路由器分配给树莓派的 ip 地址，点击最右侧的添加，再点击保存并应用。 第二条规则先输入和第一条规则一样，点击最右侧的添加，点击保存并应用，再点击修改。 退出时点击保存并应用。 完成！ 可以导出配置，以免下次折腾的时候需要重新配置！ 后续会写如何配置其他部分。 我们可以使用 ttyd 访问终端 可以通过opkg命令安装软件，就像 Ubuntu 的apt，不过这里不需要加sudo。 之前尝试安装nmap，但是会报错，这里给出一个解决办法 1vim /etc/openclash/config/config.yaml 输入以下命令，:wq保存退出。 1src/gz openwrt_nmap https://repo.turris.cz/omnia/packages/packages 更新一下。 1opkg update 验证一下，输入nmap -V 1234567# root @ OpenWrt in ~ [22:21:02] C:255$ nmap -VNmap version 7.91 ( https://nmap.org )Platform: aarch64-openwrt-linux-gnuCompiled with: libz-1.2.11 libpcre-8.44 libpcap-1.10.1 nmap-libdnet-1.12 ipv6Compiled without: liblua openssl libssh2Available nsock engines: epoll poll select","tags":["树莓派","OpenWrt"],"categories":["应用"]},{"title":"树莓派安装Ubuntu21.10","path":"/2021/11/06/015924/","content":"树莓派安装 Ubuntu21.10 下载、安装烧录工具 Raspberry Pi Imager：link 烧录过程 选择镜像 点击CHOOSE OS，选择Other general purpose OS ，再选择 Ubuntu 找到与自己树莓派相应的版本，我的是 Raspberry 4，因此选择第一个 选择 SD 卡设备 点击CHOOSE STORAGE ，选择自己的 SD 卡设备 点击WRITE 等待烧录完成，拔出 SD 卡，插入树莓派卡槽，插电源开机。至此为树莓派安装 Ubuntu 流程结束，插上显示器后效果如下","tags":["树莓派","Linux"],"categories":["应用"]},{"title":"SPI通讯协议","path":"/2021/10/09/073657/","content":"显示屏 TFT-LCD 信号接口有 SPI、MCU、RGB、LVDS、MIPI、eDP、HDMI 等等多种类型。其中就包括 SPI 协议，SPI 协议还有其他用途，FLASHRAM、网络控制器、LCD 显示驱动器、A/D 转换器和MCU等。 SPI 协议 通信原理 需要至少 3 根线，分别是 SDI（数据输入）、SDO（数据输出）、SCLK（时钟）、CS（片选） SDI – SerialData In,串行数据输入 SDO – SerialDataOut,串行数据输出 SCLK – Serial Clock,时钟信号，由主设备产生 CS – Chip Select,从设备使能信号，由主设备控制 CS是从芯片是否被主芯片选中的控制信号，也就是说只有片选信号为预先规定的使能信号时（高电位或低电位），主芯片对此从芯片的操作才有效。这就使在同一条总线上连接多个 SPI 设备成为可能。 SPI 接口 SPI 接口是在 CPU 和外围低速器件之间进行同步串行数据传输，在主器件的移位脉冲下，数据按位传输，高位在前，低位在后，为全双工通信，数据传输速度总体来说比I2C总线要快，速度可达到几 Mbps。 特点：信号线少，协议简单，相对数据速率高。 MOSI – 主器件数据输出，从器件数据输入 MISO – 主器件数据输入，从器件数据输出 SCLK –时钟信号，由主器件产生,最大为 fPCLK/2，从模式频率最大为 fCPU/2 NSS – 从器件使能信号，由主器件控制,有的 IC 会标注为 CS(Chip select) #未完待续#","tags":["机器之脉络","SPI"],"categories":["理论"]},{"title":"为VScode添加背景","path":"/2021/06/27/205243/","content":"原生的vscode无背景，没有理想的好看 那如何为VScode添加自己喜欢的壁纸呢？ 打开VScode文件所在位置，我的安装路径是C:\\Users\\用户名\\AppData\\Local\\Programs\\Microsoft VS Code\\ 再依次打开目录\\resources\\app\\out\\vs\\workbench 完整路径是: C:\\Users\\用户名\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\out\\vs\\workbench 打开文件workbench.desktop.main.css 添加如下代码 12345678910111213body &#123; /*背景图片的路径*/ background-image: url(C:/Users/用户名/123.jpg); /* 图片不重复 */ background-repeat: no-repeat; /* 图片位置 */ background-position: center; /* 图片大小 */ background-size: cover; /* 透明度 */ opacity: 0.7; /* opacity: 0.75; */&#125; Ctrl + S保存，重启VScode即可，效果如下。 可能会提示Code可能损坏，这个可以忽略，选择不再提示就可以了。","tags":["Vscode"],"categories":["折腾"]},{"title":"DS18B20测温芯片驱动代码","path":"/2021/06/02/092302/","content":"以下代码在STC15W408AS单片机进行测试，后面还有自制的PCB的原理图和layout设计（因某些原因需要制作这样一块显示温度的小项目，又想节约成本，于是画的十分简陋…） DS18B20驱动代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &quot;stc15.h&quot; //此处应修改为相应的单片机库sbit DQ = P1^1; //此处为连接DS18B20的引脚号//单总线延时函数void Delay_OneWire(unsigned int t) //STC89C52RC&#123;\tunsigned char i;\twhile(t--)\t&#123; for(i=0;i&lt;12;i++);\t&#125;&#125;//通过单总线向DS18B20写一个字节void Write_DS18B20(unsigned char dat)&#123;\tunsigned char i;\tfor(i=0;i&lt;8;i++)\t&#123; DQ = 0; DQ = dat&amp;0x01; Delay_OneWire(5); DQ = 1; dat &gt;&gt;= 1;\t&#125;\tDelay_OneWire(5);&#125;//从DS18B20读取一个字节unsigned char Read_DS18B20(void)&#123;\tunsigned char i;\tunsigned char dat; for(i=0;i&lt;8;i++)\t&#123; DQ = 0; dat &gt;&gt;= 1; DQ = 1; if(DQ) &#123; dat |= 0x80; &#125; Delay_OneWire(5);\t&#125;\treturn dat;&#125;//DS18B20设备初始化bit init_ds18b20(void)&#123; bit initflag = 0; DQ = 1; Delay_OneWire(12); DQ = 0; Delay_OneWire(80); DQ = 1; Delay_OneWire(10); initflag = DQ; Delay_OneWire(5); return initflag;&#125; unsigned char rd_temperature(void)&#123; unsigned char low,high; char temp; init_ds18b20(); Write_DS18B20(0xCC); Write_DS18B20(0x44); //启动温度转换 Delay_OneWire(200); init_ds18b20(); Write_DS18B20(0xCC); Write_DS18B20(0xBE); //读取寄存器 low = Read_DS18B20(); //低字节 high = Read_DS18B20(); //高字节 temp = high&lt;&lt;4; temp |= (low&gt;&gt;4); return temp;&#125; PCB文件及其示意图 PCB文件以压缩包形式打包。戳我下载 注：我画的是拼板，右侧的那块可能地线没有接到一起。 PCB原件布局 BOM表 Comment Description Footprint Quantity 5261AS 二位共阴数码管 5261AS 1 LED 发光二极管 0603 1 Header 4 Header, 4-Pin HDR1X4 1 Res 10K 0603 1 Res 5.1R 0603 1 STC15W408AS C51单片机 SOP-16 1 DS18B20模组 DS18B20模组 DS18B20模组 1 DS18B20模组相关文件由淘宝商家提供，以下是淘宝商家公开的百度网盘连接。 https://pan.baidu.com/s/19CwH6CAaWgVBMKmCA28ygQ 提取码：lggj 单片机代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209#include &quot;stc15.h&quot;#include &quot;intrins.h&quot;#include &quot;onewire.h&quot;#include &quot;absacc.h&quot;#define uchar unsigned char#define uint unsigned intsbit LED = P3 ^ 2; //H有效sbit DIGITAL_a = P1 ^ 2;sbit DIGITAL_b = P1 ^ 3;sbit DIGITAL_c = P1 ^ 4;sbit DIGITAL_d = P1 ^ 5;sbit DIGITAL_e = P5 ^ 4; //sbit DIGITAL_e = P2 ^ 4;sbit DIGITAL_f = P5 ^ 5; //sbit DIGITAL_e = P2 ^ 5;sbit DIGITAL_g = P1 ^ 0;sbit DIGITAL_dp = P3 ^ 7;sbit DIGITAL_H = P3 ^ 6;sbit DIGITAL_L = P3 ^ 3;//sbit DQ = P1 ^ 1;bit temper_flag = 0; //温度读取标志int temp = 0;int intr = 0;/*数码管显示数字*/void printf_num(num)&#123; if (num == 0) &#123; DIGITAL_a = 1; DIGITAL_b = 1; DIGITAL_c = 1; DIGITAL_d = 1; DIGITAL_e = 1; DIGITAL_f = 1; DIGITAL_g = 0; DIGITAL_dp = 0; &#125; /*显示1*/ if (num == 1) &#123; DIGITAL_a = 0; DIGITAL_b = 1; DIGITAL_c = 1; DIGITAL_d = 0; DIGITAL_e = 0; DIGITAL_f = 0; DIGITAL_g = 0; DIGITAL_dp = 0; &#125; /*显示2*/ if (num == 2) &#123; DIGITAL_a = 1; DIGITAL_b = 1; DIGITAL_c = 0; DIGITAL_d = 1; DIGITAL_e = 1; DIGITAL_f = 0; DIGITAL_g = 1; DIGITAL_dp = 0; &#125; /*显示3*/ if (num == 3) &#123; DIGITAL_a = 1; DIGITAL_b = 1; DIGITAL_c = 1; DIGITAL_d = 1; DIGITAL_e = 0; DIGITAL_f = 0; DIGITAL_g = 1; DIGITAL_dp = 0; &#125; /*显示4*/ if (num == 4) &#123; DIGITAL_a = 0; DIGITAL_b = 1; DIGITAL_c = 1; DIGITAL_d = 0; DIGITAL_e = 0; DIGITAL_f = 1; DIGITAL_g = 1; DIGITAL_dp = 0; &#125; /*显示0*/ if (num == 5) &#123; DIGITAL_a = 1; DIGITAL_b = 0; DIGITAL_c = 1; DIGITAL_d = 1; DIGITAL_e = 0; DIGITAL_f = 1; DIGITAL_g = 1; DIGITAL_dp = 0; &#125; /*显示6*/ if (num == 6) &#123; DIGITAL_a = 1; DIGITAL_b = 0; DIGITAL_c = 1; DIGITAL_d = 1; DIGITAL_e = 1; DIGITAL_f = 1; DIGITAL_g = 1; DIGITAL_dp = 0; &#125; /*显示7*/ if (num == 7) &#123; DIGITAL_a = 1; DIGITAL_b = 1; DIGITAL_c = 1; DIGITAL_d = 0; DIGITAL_e = 0; DIGITAL_f = 0; DIGITAL_g = 0; DIGITAL_dp = 0; &#125; /*显示8*/ if (num == 8) &#123; DIGITAL_a = 1; DIGITAL_b = 1; DIGITAL_c = 1; DIGITAL_d = 1; DIGITAL_e = 1; DIGITAL_f = 1; DIGITAL_g = 1; DIGITAL_dp = 0; &#125; /*显示9*/ if (num == 9) &#123; DIGITAL_a = 1; DIGITAL_b = 1; DIGITAL_c = 1; DIGITAL_d = 1; DIGITAL_e = 0; DIGITAL_f = 1; DIGITAL_g = 1; DIGITAL_dp = 0; &#125;&#125;/*数码管显示温度*/void printf_wendu(num)&#123; //\tprintf_num(num/10); DIGITAL_H = 0; printf_num(num / 10); // DIGITAL_H = 0; DIGITAL_H = 1; DIGITAL_a = 0; DIGITAL_b = 0; DIGITAL_c = 0; DIGITAL_d = 0; DIGITAL_e = 0; DIGITAL_f = 0; DIGITAL_g = 0; DIGITAL_dp = 0; //\tDelay_printf_wendu(); //\tprintf_num(num%10); DIGITAL_L = 0; printf_num(num % 10); // DIGITAL_L = 0; DIGITAL_L = 1; DIGITAL_a = 0; DIGITAL_b = 0; DIGITAL_c = 0; DIGITAL_d = 0; DIGITAL_e = 0; DIGITAL_f = 0; DIGITAL_g = 0; DIGITAL_dp = 0; //\tDelay_printf_wendu();&#125;void main(void)&#123;\tfloat temperature; while (1) &#123; if (temper_flag) &#123; temper_flag = 0; temperature = rd_temperature(); //读温度 temp = temperature; &#125; printf_wendu(temp); intr++; if (intr == 100) //1ms执行一次 &#123; intr = 0; temper_flag = 1; //100ms温度读取标志位置1 &#125; &#125;&#125;","tags":["DS18B20","C51"],"categories":["作品"]},{"title":"为Valine评论添加QQ头像识别","path":"/2021/04/26/140628/","content":"Valine F12 查看源码 在主题文件夹查询 Valine.js 文件，如果没有 Valine 可以去这里复制下载link 打开文件 Valine.js，Ctrl + F查询img class=&quot;vimg&quot;，注意绿色框的代码，等下要修改的部分。 查到后修改 123&#x27;&lt;img class=&quot;vimg&quot; src=&quot;&#x27; + (T.cdn + (0, s.default)(t.get(&quot;mail&quot;)) + T.params) + &#x27;&quot;&gt;&#x27;; 修改为 1&#x27;&lt;img class=&quot;vimg&quot; src=&quot;&#x27; + qq_img + &#x27;&quot;&gt;&#x27;; 要添加的代码 1234567891011//var qq_img = m.cdn + a(e.get(&quot;mail&quot;)) + m.params;var qq_img = T.cdn + (0, s.default)(t.get(&quot;mail&quot;)) + T.params;if (t.get(&quot;mail&quot;).indexOf(&quot;@qq.com&quot;) &gt;= 0) &#123; var prefix = t.get(&quot;mail&quot;).replace(/@.*/, &quot;&quot;);//前缀 var pattern = /^\\d+$/g; //正则表达式 var result = prefix.match(pattern);//match 是匹配的意思 if (result !== null) &#123; qq_img = &quot;//q1.qlogo.cn/g?b=qq&amp;nk=&quot; + prefix + &quot;&amp;s=100&quot;; &#125;&#125; 修改流程 流程： 默认还是gravator头像接口 判断是否是qq邮箱，提取前缀prefix qq头像接口是qq号，如正则筛选剔除–重命名了带英文的qq邮箱 拼接头像地址 加入src显示！ 参考博客链接：https://blog.csdn.net/cungudafa/article/details/104638730","tags":["hexo"],"categories":["折腾"]},{"title":"在material主题使用BBtalk","path":"/2021/04/25/021309/","content":"新建BBtalk页面 终端输入hexo new page bb 打开BBtalk文档 复制CDN引用下方的代码 1234567891011&lt;!-- 存放哔哔的容器 --&gt;&lt;div id=&quot;bbtalk&quot;&gt;&lt;/div&gt;&lt;!-- 引用 bbtalk --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/bbtalk@0.1.5/dist/bbtalk.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;bbtalk.init(&#123; appId: &quot;Y5IDwC47czJFXXXXXXSlU44Y-MdYXbMMI&quot;, appKey: &quot;qgrJ3nRwXXXXXXwwnVfj0uaQ&quot;, serverURLs: &#x27;https://AppID前八位.api.lncldglobal.com&#x27;&#125;)&lt;/script&gt; 终端输入hexo s效果如下,圆点位置会有偏差： 打开下方链接，复制js内容，在本地新建一个bbtalk.min.js。 https://hp-l.gitee.io/phone/bb/bbtalk.min.js 再将上文中的复制的CDN引用下方的代码 https://cdn.jsdelivr.net/npm/bbtalk@0.1.5/dist/bbtalk.min.js 改成 ./bbtalk.min.js 即 123456789101112&lt;!-- 存放哔哔的容器 --&gt;&lt;div id=&quot;bbtalk&quot;&gt;&lt;/div&gt;&lt;!-- 引用 bbtalk --&gt;&lt;script src=&quot;./bbtalk.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;bbtalk.init(&#123; appId: &quot;Y5IDwC47czJFXXXXXXSlU44Y-MdYXbMMI&quot;, appKey: &quot;qgrJ3nRwXXXXXXwwnVfj0uaQ&quot;, serverURLs: &#x27;https://AppID前八位.api.lncldglobal.com&#x27;&#125;)&lt;/script&gt; 效果如下，还需进一步调整。","tags":["hexo","material"],"categories":["折腾"]},{"title":"STM32点亮LED","path":"/2021/01/31/204609/","content":"点灯就相当于 python 的print(&quot;hello world&quot;) 定义引脚 打开工程文件后，找到相应的引脚，单击选择GPIO_Output，再右键选择 Enter User Label，输入定义的名称。 点击生成代码 点灯代码如下 123//点灯代码 LED1闪烁 HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin); HAL_Delay(300); 自动生成代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041int main(void)&#123; /* USER CODE BEGIN 1 */ /* USER CODE END 1 */ /* MCU Configuration----------------------------------*/ /* Reset of all peripherals, Initializes the Flash interface and the Systick. */ HAL_Init(); /* USER CODE BEGIN Init */ /* USER CODE END Init */ /* Configure the system clock */ SystemClock_Config(); /* USER CODE BEGIN SysInit */ /* USER CODE END SysInit */ /* Initialize all configured peripherals */ MX_GPIO_Init(); /* USER CODE BEGIN 2 */ /* USER CODE END 2 */ /* Infinite loop */ /* USER CODE BEGIN WHILE */ while (1) &#123; /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ //点灯代码 LED1闪烁 HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin); HAL_Delay(300); &#125; /* USER CODE END 3 */&#125; 连接开发板后点击RUN图标 alt=RUN alt=successfully , alt=successfully %}","tags":["STM32","CUBEIDE","C"],"categories":["应用"]},{"title":"小程序局域网控制ESP32（物联网芯片）","path":"/2020/12/16/225710/","content":"微信小程序 体验版二维码。 线上版二维码。 width=200px, bg=#f4f4f4, alt=线上版二维码 https://gitee.com/HP-L/esp32_-we-char_-connect ESP32 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138from machine import Timer,Pin,RTC #调用GPIO口调用定时器库import socketfrom emp_wifi import Wifiimport timeimport esp32import usocket# from machine import Pin, SPI, UART,I2C# 爬虫使用库import socket,re,sys,osimport urequests as requesthea = &#123;&#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.118 Safari/537.36&#x27;&#125;rtc = RTC()port = 10000 #端口号listenSocket = None #套接字import networkwifi = network.WLAN(network.STA_IF)wifi.active(True)A = Pin(17, Pin.OUT, value=0)B = Pin(12, Pin.OUT, value=1)C = Pin(14, Pin.OUT, value=1)D = Pin(27, Pin.OUT, value=1)E = Pin(26, Pin.OUT, value=1)F = Pin(25, Pin.OUT, value=1)G = Pin(33, Pin.OUT, value=1)# 爬时间def get_time_pa(): time_api_url = &quot;&quot;&quot;http://quan.suning.com/getSysTime.do&quot;&quot;&quot; r = request.get(time_api_url, headers = hea) content = r.text print(&#x27;爬取时间...&#x27;) time = re.search( r&#x27;&#123;&quot;sysTime2&quot;:&quot;(.*?)-(.*?)-(.*?) (.*?):(.*?):(.*?)&quot;,&quot;sysTime1&quot;:&quot;&#x27;, content ) print(r.text[13:29]) print(int(r.text[27:29])) print(int(r.text[23:26])) mm = int(r.text[27:29])# 分钟 hh = int(r.text[23:26])# 小时 rtc = RTC() time_date = rtc.datetime() print(&#x27;重置时间！&#x27;) rtc.datetime((time_date[0], time_date[1], time_date[2], time_date[3], hh, mm, time_date[6], time_date[7])) rtc.datetime()#自动联网def wifi_connect(): wifi_led=Pin(12,Pin.OUT) # 板载指示灯初始化 MODE1左边 wlan = network.WLAN(network.STA_IF) # 以工作站 (wlan) 模式运行，需要创建一个工作站Wi-Fi接口的实例 wlan.active(True) # 在工作站对象上调用激活方法并以True作为输入值传递来激活网络接口 start_time=time.time() # 记录开始时间 if not wlan.isconnected(): # 如果尚未联网成功 print(&quot;当前无线未联网，正在连接中....&quot;)# wlan.connect(&quot;WiFi名称&quot;, &quot;密码&quot;) # 无线网SSID、密码，开始联网 wlan.connect(&#x27;&#x27;,&#x27;&#x27;) # 无线网SSID、密码，开始联网 while not wlan.isconnected(): # 如果还未连接成功，则LED灯闪烁提示 wifi_led.value(1) time.sleep_ms(1000) wifi_led.value(1) time.sleep_ms(1000) print(&quot;正在尝试连接到wifi....&quot;) print(time.time()) if time.time()-start_time&gt;15: # 如果超过15秒还不行，就退出 print(&quot;连接失败!!!无线网连接超过15秒，请检查无线网名称和密码是否正确..&quot;) break if wlan.isconnected(): # 如果联接成功 wifi_led.value(1) # LED灯常亮 IP_info=wlan.ifconfig() print(&quot;##################################################&quot;) print(&quot;无线网已经连接，信息如下：&quot;) print(&quot;IP地址：&quot;+IP_info[0]) print(&quot;子网掩码：&quot;+IP_info[1]) print(&quot;网关：&quot;+IP_info[2]) print(&quot;DNS：&quot;+IP_info[3]) print(&quot;##################################################&quot;) get_time_pa()# 获取芯片温度# def wendu():# f = esp32.raw_temperature()# c = (f-32)/1.8# print(c)# oled.text(&quot;IC:&quot; + str(int(c)),20,0)# 远程连接传输命令函数def connect_to_phone(): try: ip = Wifi.ifconfig()[0][0] #获取IP地址 s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) #设置套接字 sockaddr = socket.getaddrinfo(ip, port) print(sockaddr[0][4]) s.bind(sockaddr[0][4]) print (&#x27;tcp waiting...&#x27;) while True: data, addr = s.recvfrom(1024) print(&#x27;From %s %s&#x27; % addr) print(&#x27;data is %s&#x27; % data) data_utf8 = bytes.decode(data) print(data_utf8) if data_utf8 == &quot;led_1_on&quot;: B.value(0) if data_utf8 == &quot;led_2_on&quot;: C.value(0) if data_utf8 == &quot;led_1_off&quot;: B.value(1) if data_utf8 == &quot;led_2_off&quot;: C.value(1) if data_utf8 == &quot;led_3_on&quot;: D.value(0) if data_utf8 == &quot;led_4_on&quot;: E.value(0) if data_utf8 == &quot;led_3_off&quot;: D.value(1) if data_utf8 == &quot;led_4_off&quot;: E.value(1) if data_utf8 == &quot;led_5_on&quot;: F.value(0) if data_utf8 == &quot;led_6_on&quot;: G.value(0) if data_utf8 == &quot;led_5_off&quot;: F.value(1) if data_utf8 == &quot;led_6_off&quot;: G.value(1) except: if(listenSocket): #判断套接字是否为空 listenSocket.close() #关闭套接字wifi_connect()connect_to_phone() 本程序可连接 OLED1306 也可不连接 OLED1306，不会因为未连接显示屏报错。 可直接将 OLED1306 与 ESP32 连接，若不显示，原因可能是接线不稳，接触不良。 注意：本程序使用的时 I2C 通讯！！！硬件连接时，I2C必须接上高电平，下面程序是方便面包板使用者使用的程序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250from machine import Timer,Pin,RTC #调用GPIO口调用定时器库import socketfrom emp_wifi import Wifiimport timeimport esp32import usocket# 爬虫使用库import socket,re,sys,osimport urequests as request# 显示屏使用库import machine, ssd1306, gfxhea = &#123;&#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.118 Safari/537.36&#x27;&#125;rtc = RTC()port = 10000 #端口号listenSocket = None #套接字import networkWIFI = Pin(17, Pin.OUT, value=0)LED_1 = Pin(12, Pin.OUT, value=1)LED_2 = Pin(14, Pin.OUT, value=1)LED_3 = Pin(27, Pin.OUT, value=1)LED_4 = Pin(26, Pin.OUT, value=1)LED_5 = Pin(25, Pin.OUT, value=1)LED_6 = Pin(33, Pin.OUT, value=1)LED_7 = Pin(32, Pin.OUT, value=1)L3 = Pin(13, Pin.OUT, value=1)# 爬时间def get_time_pa(): time_api_url = &quot;&quot;&quot;http://quan.suning.com/getSysTime.do&quot;&quot;&quot; r = request.get(time_api_url, headers = hea) content = r.text print(&#x27;爬取时间...&#x27;) time = re.search( r&#x27;&#123;&quot;sysTime2&quot;:&quot;(.*?)-(.*?)-(.*?) (.*?):(.*?):(.*?)&quot;,&quot;sysTime1&quot;:&quot;&#x27;, content ) print(r.text[13:29]) print(int(r.text[27:29])) print(int(r.text[23:26])) mm = int(r.text[27:29])# 分钟 hh = int(r.text[23:26])# 小时 rtc = RTC() time_date = rtc.datetime() print(&#x27;重置时间！&#x27;) rtc.datetime((time_date[0], time_date[1], time_date[2], time_date[3], hh, mm, time_date[6], time_date[7])) rtc.datetime()#自动联网def wifi_connect(): wifi_led=Pin(23,Pin.OUT) # 板载指示灯初始化 MODE1左边 wlan = network.WLAN(network.STA_IF) # 以工作站 (wlan) 模式运行，需要创建一个工作站Wi-Fi接口的实例 wlan.active(True) # 在工作站对象上调用激活方法并以True作为输入值传递来激活网络接口 start_time=time.time() # 记录开始时间 if not wlan.isconnected(): # 如果尚未联网成功 print(&quot;当前无线未联网，正在连接中....&quot;) wlan.connect(&#x27;***&#x27;,&#x27;***&#x27;) # 无线网SSID、密码，开始联网 while not wlan.isconnected(): # 如果还未连接成功，则LED灯闪烁提示 wifi_led.value(0) time.sleep_ms(1000) wifi_led.value(0) time.sleep_ms(1000) print(&quot;正在尝试连接到wifi....&quot;) print(time.time()) if time.time()-start_time&gt;15: # 如果超过15秒还不行，就退出 print(&quot;连接失败!!!无线网连接超过15秒，请检查无线网名称和密码是否正确..&quot;) break if wlan.isconnected(): # 如果联接成功 wifi_led.value(0) # LED灯常亮 IP_info=wlan.ifconfig() print(&quot;##################################################&quot;) print(&quot;无线网已经连接，信息如下：&quot;) print(&quot;IP地址：&quot;+IP_info[0]) print(&quot;子网掩码：&quot;+IP_info[1]) print(&quot;网关：&quot;+IP_info[2]) print(&quot;DNS：&quot;+IP_info[3]) print(&quot;##################################################&quot;)# get_time_pa()oled_str1=&#x27;&#x27;oled_str2=&#x27;&#x27;oled_str3=&#x27;&#x27;oled_str4=&#x27;&#x27;oled_str5=&#x27;&#x27;def oled_process(str1,ip,oled,graphics):# i2c = machine.I2C(scl=machine.Pin(18), sda=machine.Pin(19))# oled = ssd1306.SSD1306_I2C(128 ,64 ,i2c)# graphics = gfx.GFX(128, 64, oled.pixel) global oled_str1 global oled_str2 global oled_str3 global oled_str4 global oled_str5 oled_str1=oled_str2 oled_str2=oled_str3 oled_str3=oled_str4 oled_str4=oled_str5 oled_str5=str1 oled.fill(0) graphics._slow_vline(0, 0, 64, 1) graphics._slow_vline(127, 0, 128, 1) graphics._slow_hline(0, 15, 128, 1) graphics._slow_hline(0, 16, 128, 1) graphics._slow_hline(0, 0, 128, 1) graphics._slow_hline(0, 63, 128, 1) oled.text(&quot;port:10000 &amp; ip&quot;,0+2,0) oled.text(ip,0+2,8) oled.text(oled_str5,0+2,16+2) oled.text(oled_str4,0+2,24+2) oled.text(oled_str3,0+2,32+2) oled.text(oled_str2,0+2,40+2) oled.text(oled_str1,0+2,48+2) oled.show()# 显示屏代码def oled_try(): try: i2c = machine.I2C(scl=machine.Pin(18), sda=machine.Pin(19)) oled = ssd1306.SSD1306_I2C(128 ,64 ,i2c) graphics = gfx.GFX(128, 64, oled.pixel) print(&quot;get&quot;) connect_to_phone_oled(oled,graphics) except: print(&quot;false&quot;) connect_to_phone()# 获取芯片温度# def wendu():# f = esp32.raw_temperature()# c = (f-32)/1.8# print(c)# oled.text(&quot;IC:&quot; + str(int(c)),20,0)def connect_to_phone_oled(oled,graphics): try: ip = Wifi.ifconfig()[0][0] #获取IP地址 s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) #设置套接字 sockaddr = socket.getaddrinfo(ip, port) print(sockaddr[0][4]) s.bind(sockaddr[0][4]) oled_process(sockaddr[0][4][0],sockaddr[0][4][0],oled,graphics) print(&quot;oled&quot;) print(&#x27;tcp waiting...&#x27;) while True: data, addr = s.recvfrom(1024) print(&#x27;From %s %s&#x27; % addr) print(&#x27;data is %s&#x27; % data) data_utf8 = bytes.decode(data) oled_process(data_utf8,sockaddr[0][4][0],oled,graphics) data_size = s.sendto(data, addr) # print(&#x27;From %s %s&#x27; % data_utf8) # print(&#x27;data is %s&#x27; % data_utf8) if data_utf8 == &quot;led_1_on&quot;: LED_1.value(0)# data_size = s.sendto(&quot;led_1_on&quot;, addr) if data_utf8 == &quot;led_2_on&quot;: LED_2.value(0) if data_utf8 == &quot;led_1_off&quot;: LED_1.value(1)# data_size = s.sendto(&quot;led_1_off&quot;, addr) if data_utf8 == &quot;led_2_off&quot;: LED_2.value(1) if data_utf8 == &quot;led_3_on&quot;: LED_3.value(0) if data_utf8 == &quot;led_4_on&quot;: LED_4.value(0) if data_utf8 == &quot;led_3_off&quot;: LED_3.value(1) if data_utf8 == &quot;led_4_off&quot;: LED_4.value(1) if data_utf8 == &quot;led_5_on&quot;: LED_5.value(0) if data_utf8 == &quot;led_6_on&quot;: LED_6.value(0) if data_utf8 == &quot;led_5_off&quot;: LED_5.value(1) if data_utf8 == &quot;led_6_off&quot;: LED_6.value(1) if data_utf8 == &quot;led_7_on&quot;: LED_7.value(1) if data_utf8 == &quot;led_7_off&quot;: LED_7.value(1) except: if(listenSocket): #判断套接字是否为空 listenSocket.close() #关闭套接字def connect_to_phone(): try: ip = Wifi.ifconfig()[0][0] #获取IP地址 s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) #设置套接字 sockaddr = socket.getaddrinfo(ip, port) print(sockaddr[0][4]) s.bind(sockaddr[0][4]) print (&#x27;tcp waiting...&#x27;) while True: data, addr = s.recvfrom(1024) print(&#x27;From %s %s&#x27; % addr) print(&#x27;data is %s&#x27; % data) data_utf8 = bytes.decode(data)# print(&#x27;From %s %s&#x27; % data_utf8)# print(&#x27;data is %s&#x27; % data_utf8) data_size = s.sendto(data, addr) if data_utf8 == &quot;led_1_on&quot;: LED_1.value(0) if data_utf8 == &quot;led_2_on&quot;: LED_2.value(0) if data_utf8 == &quot;led_1_off&quot;: LED_1.value(1) if data_utf8 == &quot;led_2_off&quot;: LED_2.value(1) if data_utf8 == &quot;led_3_on&quot;: LED_3.value(0) if data_utf8 == &quot;led_4_on&quot;: LED_4.value(0) if data_utf8 == &quot;led_3_off&quot;: LED_3.value(1) if data_utf8 == &quot;led_4_off&quot;: LED_4.value(1) if data_utf8 == &quot;led_5_on&quot;: LED_5.value(0) if data_utf8 == &quot;led_6_on&quot;: LED_6.value(0) if data_utf8 == &quot;led_5_off&quot;: LED_5.value(1) if data_utf8 == &quot;led_6_off&quot;: LED_6.value(1) if data_utf8 == &quot;led_7_on&quot;: LED_7.value(1) if data_utf8 == &quot;led_7_off&quot;: LED_7.value(1) except: if(listenSocket): #判断套接字是否为空 listenSocket.close() #关闭套接字wifi_connect()oled_try() 测试视屏","tags":["ESP32","机器之魂魄","C","微信小程序"],"categories":["应用"]},{"title":"微信小程序学习笔记","path":"/2020/12/12/013940/","content":"开发文档链接 微信官方文档 文件 全局文件： app.js 全局 js 文件：js 代码全局可以调用 app.json 全局配置文件：导航栏，背景颜色，标题，窗口配置 app.wxss 全局样式文件：统一样式 utils 文件夹：封装自定义的工具 pages 小程序页面文件夹：所有的页面都在该文件夹下管理，pages 文件夹中，一个文件夹代表一个页面。 局部文件：一个页面的文件 wxml wxss js json app.json 123456789101112&#123; &quot;pages&quot;: [&quot;pages/index/index&quot;, &quot;pages/logs/logs&quot;], //页面管理 &quot;window&quot;: &#123; //窗口界面 &quot;backgroundTextStyle&quot;: &quot;light&quot;, &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;, //导航栏颜色 &quot;navigationBarTitleText&quot;: &quot;Weixin&quot;, &quot;navigationBarTextStyle&quot;: &quot;black&quot; &#125;, &quot;style&quot;: &quot;v2&quot;, &quot;sitemapLocation&quot;: &quot;sitemap.json&quot;&#125; 若要添加页面或者直接在&quot;pages&quot;: [&quot;pages/index/index&quot;, &quot;pages/logs/logs&quot;]中添加，IDE 会直接生成一个文件夹及内部页面文件。 若在全局配置中窗口界面配置了&quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;的同时，在单个页面(例如 logo 页面)的配置文件也配置了&quot;navigationBarBackgroundColor&quot;: &quot;#000&quot;，这是只有当跳转到(例如 logo 页面)时，导航栏颜色才会变成#000。 微信小程序中的 js 变量 js 变量：用于储存信息的容器 声明时使用 var+变量名，变量类型通过赋值来决定 注意：变量必须一字母开头，也可以$和_开头，大小写敏感 12345678var answer = &quot;It&#x27;s alright&quot;;var x1 = 43.0;var x = true;var cars = new Array();cars[0] = &quot;Saab&quot;;var cars = [&quot;saab&quot;, &quot;Volor&quot;];var person = null; //清空变量内容var carname; //执行后内容为undefined 对象 12345var person = &#123; firstname: &quot;John&quot;, lastname: &quot;Doe&quot;, id: 5566,&#125;; 对象寻址方式 12name = person.lastname;name = person[&quot;lastname&quot;]; 运算 +,-,*,/,% 比较运算符，返回值均为FALSE&amp;TRUE 逻辑运算符 &amp;&amp;,||,！ 123456y = 5;z = 2;x = y + z;txt1 = &quot;what a very&quot;;txt2 = &quot;nice day&quot;;txt3 = txt1 + txt2; //此时txt3 = &quot;what a verynice day&quot; 条件 if 1234567891011121314151617if (condition) &#123; //当condition为true时，才执行下面语句&#125;if (condition) &#123; //当condition为true时，才执行下面语句&#125; else &#123; //否则执行下面代码&#125;if (condition) &#123; //当condition为true时，才执行下面语句&#125; else if (condition1) &#123; //否则执行下面代码&#125; else &#123; //否则执行下面代码&#125; 循环 for 12345678for (语句1; 语句2; 语句3) &#123; //被执行的代码，语法和C语言相似&#125;var x = 0;for (var i = 0; i &lt; 5; i++) &#123; x = x + 1;&#125; 小程序中自动生成的 js 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// pages/index/index.jsPage(&#123; /** * 页面的初始数据 */ data: &#123;&#125;, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) &#123;&#125;, /** * 生命周期函数--监听页面初次渲染完成 */ onReady: function () &#123;&#125;, /** * 生命周期函数--监听页面显示 */ onShow: function () &#123;&#125;, /** * 生命周期函数--监听页面隐藏 */ onHide: function () &#123;&#125;, /** * 生命周期函数--监听页面卸载 */ onUnload: function () &#123;&#125;, /** * 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () &#123;&#125;, /** * 页面上拉触底事件的处理函数 */ onReachBottom: function () &#123;&#125;, /** * 用户点击右上角分享 */ onShareAppMessage: function () &#123;&#125;,&#125;); page 123Page(&#123; //页面内容，不写任何东西也不会报错&#125;); data 和函数 data 对象 1234data:&#123; msg:&#x27;hello!&#x27;, flag:false&#125; function 函数 123function(参数)&#123; //函数内容&#125;, 小程序的生命周期和回掉函数 12345678加载 |渲染 |显示----&gt;隐藏 | | | |卸载&lt;----隐藏 当程序运行到各个生命周期函数的节点时，会执行生命周期回调函数 回掉函数： onLoad() 页面加载时触发 onShow() 页面显示/切入前台触发 onReady() 页面初次渲染完成时触发 运行完上面流程即进入激活状态 onShow() 页面显示/切入前台触发 onHide() 页面影藏/切入后台触发 onUnload() 页面卸载时触发 onPullDownRefresh() 下拉刷新 onReachBottom()上拉触底事件 onShareAppMessage() 转发按钮，自定义转发内容 事件响应 事件：视图层到逻辑层的通讯方式，将用户的行为反馈到逻辑层 即事件可以通过在 wxml 中绑定在组件上，达到触发条件时，会触发相应的事件处理函数(事件响应)对象可以额外携带如 id,dataset 等额外信息 组建事件响应： 组件上绑定事件处理函数 点击事件绑定处理函数的方法：使用bindtap属性，属性值为 js 中的事件的事件处理函数的函数名 123&lt;view id=&quot;tapTest&quot; data-hi=&quot;WeChat&quot; bindtab=&quot;tapName&quot;&gt; Click me!&lt;/view&gt; Page 中写相应函数处理事件，单数是 event，函数名要和 wxml 中绑定的 bindtap 属性属性值一致 12345Page(&#123; tapName(event) &#123; console.log(event); //该语句将获取到的数据打印在了编译器的窗口中 &#125;,&#125;); 小程序 js 数据处理 this 关键字 this：当前对象的一个引用，在使用时往往指向的是上一层对象，在函数中执行时指向的是全局对象 访问页面数据：this.data 页面初始数据的那部分 调用页面内的函数：this.onload() 执行这一语句就会执行 onload()函数 tips: 若在 API 中使用 this，需要在调用 API 前暂存指向页面的 this，例 1var that = this; 调用方法 1234567891011121314151617Page(&#123; data:&#123; a:1, b:&#x27;balabala&#x27;, c:[&quot;a&quot;,&quot;b&quot;,] &#125;, action:function()&#123; this.data.a=666 console.log(&quot;这是新的函数&quot;) &#125;, onLoad: function(options)&#123; console.log(this.data)//调时窗口打印出data中的所有值 this.action()//调用action函数 &#125;&#125;) 页面数据更新 123456this.setData(&#123; //变量名：新的值， //变量名：新的值， //变量名：新的值 a: 8888,&#125;); 不同页面的数据出传递 方法有二，其一，页面跳转过程中携带参数。其二，将数据存于全局数据中，各个页面在从全局中读取 第二种用法：在 app.js 中 123456App(&#123; globalData: &#123; //globalData可以改成其他名称 userInfo: null, &#125;,&#125;); 各个页面与全局数据进行交互，使用getApp()历程如下: 页面的 js 文件如下 1234onLoad:function(options)&#123; console.log(getApp().globalData.abc) getApp().globalData.abc = 456&#125; app.js 文件中含有如下 12345678App(&#123; globalData: &#123; //globalData可以改成其他名称 userInfo: null, abc: 1234, d: [], &#125;,&#125;); 微信小程序的 API 介绍 API 的类型： 事件监听 API：以 on 开头用于监听 同步 API：以 Sync 结尾的 API 都是同步 API，起执行结果可通过函数返回值直接获取。当执行到 API 时，停止组件进程等待 API 执行完。 异步 API：都接受一个 object 类型的参数。程序会启动一个分支来运行 API API 内容 success 部分：接口调用成功的回调函数 fail 部分：接口调用失败的回调函数 complete 部分：接口调用结束的回调函数 微信登陆 API 123456789101112wx.login(&#123; success(res) &#123; //成功执行 &#125;, fail(res) &#123; console.log(res.errMsg); //失败执行 &#125;, complete(res) &#123; //一定执行 &#125;,&#125;); Object 类型参数包含的字段 属性 类型 说明 errMsg string 错误信息，若成功为 errCode number 错误码，成功时为 0 其他 Any 接口返回数据 调用 API 进行页面互交 消息提示框 12345wx.showToast(&#123; title: &quot;成功&quot;, //文字 icon: &quot;success&quot;, //对勾 duration: 2000, //延时时间&#125;); 模态弹窗 1234567891011wx.showModal(&#123; title: &quot;提示&quot;, content: &quot;这是一个模态弹窗&quot;, success(res) &#123; if (res.confirm) &#123; console.log(&quot;用户点击确定&quot;); &#125; else if (res.cancel) &#123; console.log(&quot;用户点击取消&quot;); &#125; &#125;,&#125;); Loading 提示框 1234567wx.showLoading(&#123; title: &quot;加载中&quot;,&#125;);setTimeout(function () &#123; wx.hideLoading(); //必须调用hideLoading才能关闭loading&#125;, 2000); 页面路由 API wx.relaunch()关闭所有页面，打开到指定页面 wx.redirectTo()关闭当前页面，跳转到指定页面 wx.navigateTo()保留当前页面，跳转到指定页面 wx.navigateBack()关闭当前页面，返回上一级或多级页面 123456789101112131415wx.relaunch(&#123; url: &quot;/pages/jsjs/jsjs&quot;,&#125;);wx.redirectTo(&#123; url: &quot;../jsjs/jsjs&quot;,&#125;);wx.navigateTo(&#123; url: &quot;/pages/jsjs/jsjs&quot;,&#125;);wx.navigateBack(&#123; delta: 1,&#125;);","tags":["微信小程序"],"categories":["理论"]},{"title":"ESP32_物联网那些事","path":"/2020/12/03/154423/","content":"ESP32_物联网那些事 通过查阅资料，ESP32 是一款物联网模块，它支持 TCP/IP 协议，于是我们可以使用 socket 通讯，实现局域网通信，它也支持 MQTT 通讯，呵远程连接到阿里云。下面的链接有详细的使用说明。 Socket 通信 使用物联网第一步：烧录固件 这里提到的固件是micropython官方出的固件，我在网上还看到了不少通过C语言写.bin固件的教程，可以写自己需要的固件刷入到ESP32中 可以参考这篇文章 ESP32_micropython固件烧录 如何连接到 WiFi？ Micropython联网同步时间 ESP32 是可以使用 REPL 的，REPL 就像局域网下的 VSCode，可以在浏览器上编写程序，可惜他不能开机自启，于是就有人开发了一款叫做 EMP 的 IDE ，下面有链接。 EMP项目简介 我在执行原文提供的代码时发现set_boot_mode()报错 原文提供的代码 123456789101112&gt;&gt;&gt; from emp_boot import set_boot_mode&gt;&gt;&gt; set_boot_mode()&gt;&gt;&gt; from emp_boot import set_boot_mode&gt;&gt;&gt; set_boot_mode()[0] Boot with nothing attention: this option will clear up boot.py, careful![1] Boot with wifi startup this mode will auto start wifi connect program.[2] Easy to develop this mode is for developers.In this mode you can develop much easier via EMP- IDE(emp.1zlab.com)Please input your choice [0-2]: 下面给出解决方案： 在 ESP32 的 boot.py 中所有代码替换成如下代码： 1234567891011121314151617181920from emp_wifi import Wififrom emp_webrepl import WebREPLfrom emp_utils import webrepl_passfrom emp_utils import post_ipfrom machine import Pin # 引用LED使用import timewifi_LED = Pin(12, Pin.OUT, value=1) #定义LEDif __name__ == &#x27;__main__&#x27;: Wifi.connect() post_ip(Wifi.ifconfig()[0][0]) wifi_LED.value(0) time.sleep(0.5) wifi_LED.value(1)# WebREPL.start(password=webrepl_pass())# from emp_ide import *&#x27;&#x27;&#x27;上面两行是调用emp_ide，取消注释就可以使用emp_ide，这里注释掉的原因是想直接调用连接WiFi的函数不使用emp_ide&#x27;&#x27;&#x27; 在按复位即可，终端中会提示连接网络并且输入密码，连接过的 WiFi 会被记住，下次连接自动连，非常方便 利用 ESP32 联网实现一些小功能 我们可以通过 socket 通讯使得 PC 可以传输数据流到 ESP32 中，下面是代码，这里仿照的是Socket 通信文末的代码，原文中代码只能传输字节，下面代码可以传输中文字符，通过定义 IO 口可以实现局域网点亮 LED，甚至舵机。 ESP32 TCP 服务端 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from machine import Timer,Pin,RTC #调用GPIO口调用定时器库import socketfrom emp_wifi import Wifiimport networkwifi = network.WLAN(network.STA_IF)wifi.active(True)# 远程连接传输命令函数def connect_to_phone(): try: # 注意：线连接到WiFi网络！ # 如果未连接到网络，以下是连接到网络的代码 # Wifi.connect() ip = Wifi.ifconfig()[0][0] #获取IP地址 listenSocket = socket.socket() #创建套接字 listenSocket.bind((ip, port)) #绑定地址和端口号 listenSocket.listen(1) #监听套接字, 最多允许一个连接 listenSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) #设置套接字 print (&#x27;tcp waiting...&#x27;) while True: print(&quot;accepting.....&quot;) conn, addr = listenSocket.accept() #接收连接请求，返回收发数据的套接字对象和客户端地址 print(addr, &quot;connected&quot;) while True: data = conn.recv(1024) #接收数据（1024字节大小） if(len(data) == 0): #判断客户端是否断开连接 print(&quot;close socket&quot;) conn.close() #关闭套接字 break # print(data) code_utf8 = bytes.decode(data) print(code_utf8) ret = conn.send(data) #发送数据 if code_utf8 == &quot;led1 open&quot;: B.value(0) if code_utf8 == &quot;led2 open&quot;: C.value(0) if code_utf8 == &quot;led1 down&quot;: B.value(1) if code_utf8 == &quot;led2 down&quot;: C.value(1) except: if(listenSocket): #判断套接字是否为空 listenSocket.close() #关闭套接字wifi_connect() PC 端 123456789101112131415# -*- coding: UTF-8 -*-# PC TCP Clientimport socket # 导入 socket 模块s = socket.socket() # 创建 socket 对象host = &#x27;192.168.2.231&#x27; # esp32 ipport = 10000 # 设置端口号s.connect((host, port))if __name__ == &#x27;__main__&#x27;: while True: msg = raw_input(&#x27;&gt;&gt;&gt; &#x27;) s.send(msg)","tags":["ESP32","机器之魂魄"],"categories":["应用"]},{"title":"STM32开发环境搭建","path":"/2020/11/25/133600/","content":"准备工作 Integrated Development Environment for STM32 汉化和安装主题请参考下面的链接 https://blog.csdn.net/wct3344142/article/details/104142863 我使用的网址是 1http://mirrors.ustc.edu.cn/eclipse/technology/babel/update-site/R0.18.1/2019-12/ 选项和上面的链接里的不一样 thonny_download.png 新建工程 流程如图(点开查看大图)","tags":["STM32","CUBEIDE"],"categories":["工具"]},{"title":"搭建Arduino_ESP2866环境","path":"/2020/11/21/080345/","content":"下载 Arduino IDE Arduino 官网 Arduino IDE 1.8.13 下载完成后打开 arduino.exe 添加 json 文件 打开首选项 在开发板管理器网址填入 1https://arduino.esp8266.com/stable/package_esp8266com_index.json 或者 1http://wechat.doit.am/package_esp8266com_index.json 在GitHub 上的项目里有最新的版本，但是需要科学上网所以选择第二个 添加 ESP8266 开发板 搜索栏键入 8266 如果出现下载失败可以从这里下载 如果安装过其他版本的 esp8266sdk，请先删除，再使用本安装包。 解压完成后，再打开 Arduino IDE，即可在 菜单栏&gt;工具&gt;开发板 中找到你使用的 esp8266 开发板。 来自 Arduino 中文社区的大佬 https://share.weiyun.com/5CGEKJO 安装完成后重启 Arduino IDE 就会有显示了","tags":["C++","Arduino"],"categories":["应用"]},{"title":"手机定时切换壁纸","path":"/2020/11/15/124740/","content":"准备 手机安装 termuxAPP 和 termux_API (这里给出参考博客链接) 国光的 Termux 高级终端安装使用配置教程 跳转下载链接 API 下载链接 完成基础的安装 12pkg install termux-api #termux-APIpkg install cronie #linux 定时软件 编辑定时运行的 shell 脚本 编辑 bizhi.sh 文件 123456#!/bin/bashtermux-wallpaper -f ./壁纸所在目录/$((RANDOM%152+1)).jpg# $((RANDOM%152+1))是用来随机取数的# $((RANDOM%152+1))可以换成文件名 编辑定时任务文件 终端输入 1crontab -e 再输入 12# 每隔五分钟执行一次bizhi.sh文件*/5 * * * * ./文件路径/bizhi.sh 应为 Termux 默认不启动 crontab，所以进入 Termux 要开启一下 1crond start #开启 在手机设置中，termux 和 termux-API 都开启手动管理","tags":["termux"],"categories":["折腾"]},{"title":"Micropython联网同步时间","path":"/2020/11/09/074114/","content":"ntp 服务器可以自己选择，可以使用爬虫爬去时间也可以用 NTP 服务器同步，将 wifi_connect()函数最后一行 get_time_py 换成 get_time()即可 直接上程序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788# This file is executed on every boot (including wake-boot from deepsleep)#import esp#esp.osdebug(None)#import webrepl#webrepl.start()#使用ESP32上的MicroPython連接Wi-Fi網絡from machine import Pin,RTCimport network #網絡模塊import time #計時器模塊import ntptime #ntptime網絡時間協議模塊#自动联网def wifi_connect(): wifi_led=Pin(18,Pin.OUT) # 初始化LED燈，可自定義 wlan = network.WLAN(network.STA_IF) # wlan.active(True) # 激活網絡接口 start_time=time.time() # 記錄開始時間 if not wlan.isconnected(): # 如若聯網失敗 print(&quot;当前无线未联网，正在连接中....&quot;) # wlan.connect(&quot;此处改为你的无线网名称&quot;, &quot;无线网密码&quot;) wlan.connect(&#x27;XXXXXXXX&#x27;,&#x27;XXXXXXXX&#x27;) # 無綫網SSID、密碼 while not wlan.isconnected(): # 如若還未連接成功，LED則會以閃爍的方式提示未連接到WIFI wifi_led.value(0) time.sleep_ms(1000) # 延時函數1000毫秒 wifi_led.value(1) time.sleep_ms(1000) print(&quot;正在尝试连接到wifi....&quot;) print(time.time()) if time.time()-start_time&gt;15: # 如若超過15秒還未連接則退出鏈接 print(&quot;連接失敗!!!請檢查無綫網名稱和密碼是否正確...&quot;) break if wlan.isconnected(): # 如若連接成功 wifi_led.value(1) # LED燈常亮 IP_info=wlan.ifconfig() print(&quot;##################################################&quot;) print(&quot;已連接WIFI，信息如下：&quot;) print(&quot;IP地址：&quot;+IP_info[0]) print(&quot;子網掩碼：&quot;+IP_info[1]) print(&quot;網関：&quot;+IP_info[2]) print(&quot;DNS：&quot;+IP_info[3]) print(&quot;##################################################&quot;) get_time_py()#同步時間def get_time(): print(&quot;同步時間&quot;) print() print(&quot;同步前本地時間：%s&quot; %str(time.localtime())) print(&quot;##&quot;) ntptime.NTP_DELTA = 3155644800 # 設置 UTC+8偏移時間（秒），不不設置就是UTC0# ntptime.host = &#x27;pool.ntp.org&#x27; # 可選ntp服務器為阿里雲服務器，默認是&quot;pool.ntp.org&quot; ntptime.host = &#x27;edu.ntp.org.cn&#x27;# ntptime.host = &#x27;210.72.145.44&#x27; # 國家授時中心服務器IP地址# ntptime.host = &#x27;ntp1.aliyun.com&#x27;# ntptime.host = &#x27;cn.ntp.org.cn&#x27; ntptime.settime() # 修改設備時間 print(&quot;同步后本地時間：%s&quot; %str(time.localtime())) print(&quot;##################################################&quot;) rtc = RTC() print(rtc.datetime())# 爬取時間def get_time_py(): time_api_url = &quot;&quot;&quot;http://quan.suning.com/getSysTime.do&quot;&quot;&quot; r = request.get(time_api_url) content = r.text print(&#x27;爬取時間...&#x27;) time = re.search( r&#x27;&#123;&quot;sysTime2&quot;:&quot;(.*?)-(.*?)-(.*?) (.*?):(.*?):(.*?)&quot;,&quot;sysTime1&quot;:&quot;&#x27;, content ) print(r.text[13:29]) print(int(r.text[27:29])) print(int(r.text[23:26])) mm = int(r.text[27:29])# 分鐘 hh = int(r.text[23:26])# 小時 rtc = RTC() time_date = rtc.datetime() print(&#x27;重置時間！&#x27;) rtc.datetime((time_date[0], time_date[1], time_date[2], time_date[3], hh, mm, time_date[6], time_date[7])) rtc.datetime()#開始執行聯網wifi_connect()","tags":["ESP32","micropython"],"categories":["应用"]},{"title":"ESP32_micropython固件烧录","path":"/2020/11/05/094023/","content":"ESP32_micropython 固件烧录 烧录准备 1.micropython IDE：Thonny 2.ESP32 的 micropython 固件：戳我进下载页面，micropython 还支持其他芯片link，下载页面有很多固件选择，由于我的是不带 SPIRAM 的，因此我选择了第一个。 3.烧录工具： 这里提供两种，esptool 在 GitHub 上有教程，这里就不细讲。 esptool：github link Thonny: micropython IDE Flash 下载工具：link 4.ESP32 模组： 打开淘宝… 烧录过程 使用 Thonny 烧录 点击工具栏运行，选择“选择解释器…” 选择我们在 Micropython 官网下载的固件后点击 install 这是从 ESP 官网上下载的启动模式方法： 即GPIO0和GPIO2全部接地，同时按下复位按键，保持1毫秒再断开GPIO0断开接地（因为 GPIO0 默认上拉），便开始下载。 使用 Flash 下载工具 从官网下载了工具后双击打开，等待几秒后，点击 ESP32downloadTools，选择我们在 Micropython 官网下载的固件后点击 START 再按照上文中的启动方法启动即可下载。 成功之后 shell 会出现下图： 像 python 一样可以实时输入，ESP32 可以直接看到 LED 灯被点亮","tags":["ESP32","micropython","机器之魂魄"],"categories":["应用"]},{"title":"English","path":"/English/index.html","content":"English - World Travel No time, No sex, No love, Only 996! (not 985 or 211) 单词速记 单词速记: 根据字母的起源、通假字、思维导图来记忆（元音、清辅音、辅音） 语法 Grammar 成分 词性 定义 主语/从句 名词性 陈述对象：动作发出者或谈论的话题 谓语 动词性 陈述内容：主语的动作或状态 （是…人或…的） 宾语/从句 名词性 动作的承受者 表语 名词性（身份）形容词性（特征） 又叫主补，补充说明主语身份 （…人)或特征(…的） 补语 大致同 表语 主要指宾补，补充说明宾语 同位语/从句 名词性 补充解释说明 主宾表 定语/从句 形容词性 限定、修饰 主宾表 状语/从句 副词性 主要修饰 谓语动词 虚拟句 情绪状态 虚-假的，拟-假设 不可能发生的事情 or 和假设相反的 用来加强语气，表达强烈的情绪 反问句 介词: preposition 简写prep. 介词通常位于名词或代词之前。 使役动词，就是迫使、着急去做，所以才把to省略 句型结构 Sentence Structure 英文: 前少后多 (头重脚轻，外国人不习惯) That I love you is a lie. =&gt; It(形式主语) is a lie that I love you. 简单句 1. 主语 + 谓语(vi.) : 主语做了。动作 Jerry won. 杰瑞赢了 Tom cried. 汤姆哭了 2. 主语 + 谓语(系动词) + 表语 : 主语是。或。的 Jerry is a mouse. Tom is very/really/super stupid. 3. 主语 + 谓语(vt.) + 宾语 : 主语对宾语做了。动作 Jerry bit Tom. Tom ate Jerry. 4. 主语 + 谓语(vt.) + 间接宾语 + 直接宾语 : 主语。给某人。某物 Tom gave Jerry a cake. Jerry gave Tom a hug. 5. 主语 + 谓语(vt.) + 宾语 + 宾补 : 主语让宾语变为。或。的；主语看到/听见。宾语做。动作 Jerry made Tom angry. Jerry made Tom a fool. Tom saw Jerry eating in the kitchen. 复杂句 主语从句 + 宾语从句 + 同位语从句（隐藏的复杂句， 2个独立句子） 并列 and/in addition: 主谓 and 主谓 转折 but/while/however: 主谓 and 主谓 选择 or: 主谓 and 主谓 递进 from … to 关注: 有道逻辑英语 回复: 关联词 链接: https://mp.weixin.qq.com/s/bp3_VRQsnx1wuwnbaWa_PA 祈使句 (you) kiss me! – 面对面说话，可以省略主语 愿望句 (I) fuck you! – 面对面说话，可以省略主语 目录 Catalog 常用口语 Scene: Daily Speaking 机场口语 Scene: Airport Speaking 国家中英文对照表 所以学好英文，出国见见世面？ 国家中英文对照表: https://github.com/apachecn/English/tree/master/docs/CounttryList.md 26个字母 : 逻辑构造 词根字典: https://www.youdict.com/root/search 单词连读 what is it读成/i-zit/ zi + t here it is读成/i-tiz/ ti + z 5个元音: a e i o u 21个辅音: 其他 5个元音: 地位卑微 元音字母可以任意的改变: : 而不改变单词意思 互换位置 加减字母 sit set seat 前缀 词根 单词实例 a/a+辅音=ac=a: d=af=ap=at to 方向 / 加强语气 a-bridge accountant affluend apparatus attenuate ab 否定 abrupt abhor add 增加 addendum anti 反对, 抗, 防 antibody antipathy cert certain 一定确定，表示sure certficate co/com/con/co+辅音 一起、共同、全部 commemorate consonant colloquial contra 反对，相反 contradict de 向下，否定 deposit deprecate e/ex/e+辅音 向外(让它出来，使动) excite elaborate eu 好 eulogy dis 否定,不同 /分开，散开 dislike disput / dispose in in/ir/il/i bmp =&gt; im 向内，向内 / 进入、使动 / 进入某中状态、否定 / 进入某种状态，进入另一种极端，反义同源、加强 intuition intractable impetus bene 好 benefit 好处 benediction benefactor beneficial en 进入、使动: 进入某中状态 enclosure un 否定: 进入某种状态，进入另一种极端，反义同源 re 再次/往回 rebuild, return sym 相同 same sympath anto bi bio counter inter kilo mid mini mis non post pre, pro 往前，前面 re sub super tele trans tri under 后缀 名词后缀 词根 单词实例 ain captain age ance, ence ant accountant vaction ate graduate atus ect et、it、ot 小的意思 er, or hood ian ic ion, tion, ation, ition benediction / radiation / deposition ish ist artist itude ity ium 多表示地点 auditorium ment ness o radio ology or benefactor doctor shop sion ty ue dialogue ure exposure us radius y eulogy 动词后缀 词根 单词实例 ate 动词后缀 liquidate en ete deplete ish finish fy, ify satisfy / notify ize, ise le entangle 形容词后缀 词根 单词实例 able, ible, ble 能够 credible tangible al capital ant important ate elaborate ent ful ial colloquial ic, ical basic / ecumenical id 的 valid ious delicious ish itary solitary ite polite ive destructive less ly ous 多的意思 famous 著名的: 名声很多的 dangerous 危险的: 很多的 some y 副词后缀 ly ward wise 词根 a 字母 adult: 成人 =&gt; adultate v. 谄媚，奉承（成年人的那一套） adult + ate: 动词后缀 alt =&gt; 高 : 来源 tall =&gt; altitude 高度 alt + itude: 名称后缀 ami =&gt; 爱 （来源于丘比特的拉丁文名字） =&gt; amiable 可爱的、和蔼的 angu =&gt; 苦恼 （angry 生气） =&gt; anguish v. 极度痛苦 angu + ish: 动词后缀 ass =&gt; 屁股 =&gt; assassinate （变态的）暗杀 ass: 屁股 + ass: 屁股 + in + ate: 动词后缀 audi =&gt; 听 =&gt; auditorium 礼堂、听众席 audi: 听 + or: 名词后缀 + ium: 名词后缀 auth: author 作者（联想记忆） =&gt; authentic adj. 可靠的，可信的（作者是最有权威，我们考试就是用作者的文章） author + ent + ic: 形容词后缀 avi =&gt; 鸟 =&gt; aviation 航空 avi: v 翅膀的样子 + ation: 名词后缀 b=p 字母 b =&gt; 木头：一般木棒就是上下不规整的 =&gt; bar 小木棒 =&gt; ban 禁止 bar: 王磊 car: 李磊 far: 孙磊 mother -&gt; father -&gt; brother 类似汉语起名字: 性不同，名一样 b/c/f 代表意思 ar 代表后缀 对比: 如果没前缀 对比 b + atch / c + atch: 一批，一群，一组 联系: b 帮: bang 对比 be + verage / a + verage: 饮料 联系: be =&gt; beer 啤酒 brush 刷子 blush 脸红 br =&gt; 一分为二，一分为多 break =&gt; brook 支流、消息 : cook、book =&gt; branch 树枝、分支 : lunch、bench =&gt; brain 大脑（内部很多分支） : gain、rain =&gt; bruch 刷、刷子 : rush 冲 =&gt; break 打碎 : weak 虚弱、弱的 =&gt; brittle 易碎的、脆弱的 br: break + ittle: little bo =&gt; 崩，爆炸的意思 =&gt; bomb 爆破的声音 bread 面包、钱 aboard 在: 船、飞机、公共汽车、火车等上 abroad 广阔的、出国 broadcast 广播 broad 广 + cast 信号 ballot 小球，选票 -&gt; white ballot 好球 -&gt; black ballot 坏球 brev / brevi: 短 brevity - brief(简短的，简洁的；短暂的，摘要；概要) =&gt; abbreviate 简短，缩略 ab: ad(to的意思) + brevi + ate: 动词后缀 c=k 字母 c: 弯曲、包含、抓（可以用来保护自己） =&gt; cave 山洞 ca: 包裹、抓、运输 =&gt; cave 山洞 =&gt; camp -&gt; comp 梳头的感觉（用手去抓） =&gt; camp 野营 =&gt; camel 骆驼（驼峰和头之间的形状 C） -&gt; l 清辅音，由 came + l =&gt; car 车子，运输工具 =&gt; cabbage 卷心菜 page 页 wage 薪水 cage 鸟笼 calc / calci/ calcul: 石头 chalk 粉笔 =&gt; caleium 钙 calc + ium: 名词后缀 =&gt; calculate 计算: 一天一个小石头，用于计数 calcul + ate: 动词后缀 =&gt; calcify 钙化，使成石灰 calci + fy: 动词后缀 cand: 白色 =&gt; candle 蜡烛（白色的） =&gt; candy 糖果（以前是白色） =&gt; candid 公正的，坦白的，正直的 cand + id: 形容后缀 =&gt; candidate 候选人 cand + id: 形容词后缀 + ate: 名词后缀 graduate 毕业、毕业生 cap / capit / capt: 头 =&gt; capital 首都, 首都的 capit + al: 形容词后缀 =&gt; captain 队长、船长、老大，用帽子罩着大家 capt + ain: 名词后缀 cape: 斗篷、披肩 =&gt; excape 逃跑: 斗篷脱掉，方便逃跑 ex: 向外 + cape cat = kat : 来源 kitty 猫 - 元音字母可以自由转换 cevie: 拿 receive 客观上的接受、接收 - 不是主动 =&gt; deceive v. 欺骗（故意让你抓到错误的） de: 否定 + ceive celer: 噻啦，马奔跑的声音 =&gt; accelerate 加速 ac 加强语气 + celer 噻啦，马奔跑的声音 + ate 动词后缀 cess: 走 =&gt; access 行走; 走路; 前进; 接近入口; 通道; 通路 access + ible: 形容词后缀 =&gt; concession 妥协，让步(大家共同走一步) con: 共同 + cess: 走 + ion: 名词后缀 =&gt; process 队列行进，处理，加工 pro: 向前 + cess: 走 =&gt; recession 退步(往回走) re: 往回走 + cess: 走 + ion: 名词后缀 å =&gt; success 成功(一直往下走，没有后退) suc: 向下 + cess: 走 cl: 合成 =&gt; class 班级，由很多人合成的 =&gt; club 俱乐部，由很多人合成的 =&gt; clap 鼓掌，把两个手合在一起 clos: 关闭 close =&gt; enclosure 围住、围栏 en: 使、让 + clos: 关闭 close + ure: 名词后缀 =&gt; closet 小隔间（关人的小隔间） clos: 关闭 close + et: 名词后缀(小的意思) toilet 厕所，排油的小隔间 t+ oil: 油 oily 油的 + et: 名词后缀(小的意思) blanket 毛毯，覆盖（来源于 小白布，不吉利） blank: 空白 blac 白色 &lt;-&gt; black 黑色（反义同源） + et: 名词后缀(小的意思) count: 数 =&gt; accountant 会计 ac: ad 表示 to 去做的 + count + ant: 名词后缀 cred: 相信 credit card 信用卡 =&gt; credible adj. 可信的 cred + ible: 形容词后缀 =&gt; credentials n. 证明书 证件 cred + ent: to be + ial: 名词后缀 cuss: 摇动 =&gt; discuss dis-, 分开，散开 -cuss, 摇，震 =&gt; concussion 脑震荡 con + cuss: 摇动 discuss + ion: 名词后缀 d=t : 两个典型的重音，发音类似，和汉字的通假字相似 ford 福特 + 福德 letter 勒特、勒的 sit -&gt; sid : 可坐有关 sident study 学习 student 学生 d 字母 向下 de =&gt; 否定 =&gt; destructive 破坏性的 de: 否定 + struct: 建立 structrue + ive: 形容词后缀 =&gt; deprive 剥夺 de 否定 + prive: 单个 =&gt; private 私人的 delic =&gt; =&gt; delicate 精巧的，精致的 delic + ate: 形容词后缀 =&gt; delicious 好吃的: 一般都很花心思、花时间，自然就很精巧、精致 dent =&gt; 牙齿 =&gt; identity 牙齿意味着身份（奴隶社会的买卖，看牙齿就知道健康程度） i: 加强语气 + dent 牙齿 + ity: 名词后缀 dict: 说话 dictionary 字典相当于会说话的老师，你不懂就可以查它 =&gt; benediction n. 祝福 bene: 好 benefit 好处 + dict + ion: 名词后缀 =&gt; contradict n. 反驳 contra: 反对，相反 + dict dig 向下、deep 深、down 下降 =&gt; 向下 dis: 否定，不同 =&gt; disput v. 争论（想法不一致导致的讨论） dis: 否定，不同 + put: 思考 computer 计算机，做计算做思考 rect: 正, 直（表示方向） direction =&gt; directory n. 人名地址簿，电话本(给你指明方向的) di: 通过 + rect + ory: 名词后缀 t 字母 十字碑的坟墓 t =&gt; 表示一种趋势 =&gt; want =&gt; to =&gt; tend lend mend tomb - 坟墓 comb bomb tang: 触碰， 来源于 探戈 💃，亲密接触的舞蹈 =&gt; tangible adj. 能触碰到的、可理解的，有形的 tang + ible: 形容词后缀 =&gt; intangible adj. 无法琢磨的、难以理解的，无形的 in: 否定 + tang + ible: 形容词后缀 =&gt; entangle v. 使纠缠 en: 使，让 + tang + le: 动词后缀 tenu: 细, 薄 tend? 趋势 =&gt; attenuate v. 变薄 at: ad - to 方向 + tenu + ate: 动词后缀 =&gt; extenuate v. 掩饰, 减轻罪行(向外把罪行慢慢稀释、变薄) ex: 向外 + tenu + ate: 动词后缀 =&gt; tenuous adj. 稀薄, 细的 tenu: 细, 薄 tend? 趋势 + ous: 形容词后缀 famous ter: 土地 “Terra”一名的含义为“地球、星球”,罗马神话故事中,Terra是大地女神 =&gt; exteror n.外部 adj.外部的 ex: 向外 + ter + or: 名词后缀 tim: 胆怯 time 时间一去不复返，所以害怕（犯错就不怕，可以重新再来） =&gt; timorous 胆小的，胆怯的 tim + or: 名词后缀 + ous: 形容词后缀 tract: 拉得住，拽得住 =&gt; intractable 倔强的(拉/拽不住的) in: 否定 + tract + able: 形容词后缀 tri: 摩擦 (contrite 懊悔-然后两个手会不自主的摩擦) =&gt; detrimental adj. 有害的，不利的 de: 向下，否定 + tri + ment: 名词后缀 + al: 形容词后缀 e 字母 end =&gt; 结尾 =&gt; addendum n. 附录，补充 add: 增加 + end: 结尾 + um: 名词后缀 e / ex / e+辅音 开头: 向外 =&gt; exit 出口、推出 =&gt; extra 额外 extraordinary 不平凡、极端的、不可思议的 extreme 极其的、非常的 ecu: 房子 eco =&gt; ecumenical adj. 全基督教的，普遍的 ecu + men: 人 + ical: 形容词后缀 f 字母 fact: 做 factory 工厂就是做事的地方 =&gt; benefactor n.行善者 bene: 好 benefit 好处 + fact + or: 名词后缀 fall: 错误(经常跌倒，就是犯错) =&gt; fallacious adj. 错误的 fall + acious: 形容词后缀 fic: 做 fiction 小说使人虚构，做出来的 =&gt; beneficial 有益的，有利的 bene: 好 benefit 好处 + fic + ial: 形容词后缀 =&gt; certficate 证书 cert: certain 一定确定，表示sure + fic + ate: 名词后缀 fine =&gt; 好到最优程度，就开始不好了 =&gt; 好的意思 =&gt; 罚款的意思 final/finally =&gt; 好到最后就结束了、最终的 flu: 流 =&gt; affluend 富裕的: 富得流油的 af: 加强语气 + flu: 流 + ent: 形容词后缀 g 单词 gen: 基因 =&gt; genetices n. 基因学 gen + et: 小东西 wallet 压缩版的小房子 + ics: 名词后缀 多表示学科 gener =&gt; 产生 =&gt; generate 产生 gener + ate: 动词后缀 greg: 群体 group =&gt; gregarious adj. 群居的，社交的 grep + ari: ary 名词后缀 + ous: 形容词后缀 h 字母 hil: hill 高山 =&gt; exhilarate 使高兴 ex: 向外 + hilar: 开心，高兴（hil -&gt; hill 高山） + ate: 动词后缀 hor: 颤抖，害怕 horrible =&gt; abhor v. 憎恨 ab: 强调语气 + hor i 字母 in: 进入、使动: 进入某中状态、否定: 进入某种状态，进入另一种极端，反义同源、加强 =&gt; intuition 直觉: 不用教，上来就会的 in: 否定 + tuit: 教 + ion: 名词后缀 j 字母 ject: 仍，投射 =&gt; inject v. 注射 in: 向内 + ject =&gt; reject v. 拒绝 re: 往回 return + ject =&gt; eject v. 喷射、喷出 e: 向外 + ject jud: 判断 judge =&gt; prejudice 偏见 pre: 提前 + jud + ice: 名词后缀 m mal: 坏 male 男人不坏，女人不爱 =&gt; malpractice n. 玩忽职守 mal + practice 学习，实践 memor =&gt; commemorate 纪念 com + memor: 记忆 memory + ate: 动词后缀 =&gt; compensate v. 赔偿 com + pens: 花费 expensive 昂贵失望 + ate: 动词后缀 metr: 测量 meter 米 =&gt; symmetry n.对称，整齐 sym: 相同 + metr asymmetry n.不对称，不整齐 a: 否定前缀 + sym: 相同 + metr min: 小 =&gt; diminish v. 减少，下降 di: 向下 + min + ish: 动词后缀 finish n=r=l 清辅音 由于误写造成的，例如：莎士比亚当年写的时候，羽毛慢慢没水了 n -&gt; r -&gt; l : 慢慢羽毛没水、字慢慢写不显\b了 man -&gt; male &lt;=&gt; female : 反义同源 rose =&gt; 罗丽丝 （r 和 l 类似） set -&gt; sert : 口音问题造成的误读， r是清辅音，很容易误插入到单词中 =&gt; insert 向里放置，插入 present 提前到了，出席 absent ab否定前缀， sent -&gt; sert -&gt; set 坐的意思，整体就是：未坐，缺席 l =&gt; 长的意思 l =&gt; long 长的意思 =&gt; line 线条 labor =&gt; 劳动 =&gt; collaborate 合作，协作 col + labor: 劳动 + ate: 动词后缀 =&gt; elaborate 精心制作的: 付出很多精力做出来的东西 e: 向外、付出 + labor: 劳动 + ate: 形容词后缀 log / loqu: 说话 log 作为词根：说；如果单词：日志 =&gt; colloquial adj. 口头的(全都和表达说话相关的，就是口头的) col: com 全部，所有 + loqu + ial: 形容词后缀 =&gt; catelogue 小册子，目录，在下面给大家说的话 cate: 下面， 向下 + log + ue: 名词后缀 =&gt; eulogy n. 颂词 eu: 好 + log + y: 名词后缀 lime / line: 线 line 通假字 =&gt; limestone 石灰石(划线的石头) lime + stone 石头 n 字母 nat: 出生 nature 自然孕育一切, 天然的 native 与生俱来的；天赋的 =&gt; innate adj. 天生的(出生内部就带来的，出生就有的，与生俱来的) in: 向内 + nat + ate: 形容词后缀 not: 知道 =&gt; notify v. 通知(让人知道) not + ify: 动词后缀 nov: 新 now =&gt; renovate v. 翻新，修复 re: 反复不断，再一次 + nov + ate: 动词后缀 numer: 数字 =&gt; numerous adj. 大量的，数量很多的 numer + ous: 形容词后缀 多 nym / onym: nym - name 名字 =&gt; anonymous 无政府主义的 an: 否定 + onym: nym - name 名字 + ous: 形容词后缀 r 字母 rad /radi /radic: 辐射，跟 =&gt; radio n. 广播 radi + o: 名词后缀 =&gt; radius n. 半径 radi + us: 名词后缀 =&gt; eradicate v. 根除 e: ex向外 + radic + ate: 动词后缀 =&gt; radiation n.辐射 radio + ation: 名词后缀 re =&gt; 再一次 =&gt; rebuild 重建 =&gt; recit v. 背诵 re: 再一次 + cit: 唤起 excited 兴奋表示唤起内心的一种情绪 =&gt; review 检查 =&gt; return 返回 =&gt; reply 回复 ridge =&gt; abridge v.删减: 桥梁用于缩减距离 a: ad 表示 to 方向 + bridge riv: 流 river derive 出自，源于 de: 加强语气 + riv + e rupt: 打断,破坏, 爆破 ripe 熟的、爆破 =&gt; abrupt 突然的、唐突的、无理的 ab + rupt 爆炸 =&gt; erupt （火山）向外 + 爆发 e: 向外 + rupt 爆炸 =&gt; bankrupt 银行爆炸了，就是破产 p 字母 pan =&gt; 胖有关 =&gt; panda 大熊猫 =&gt; expand 膨胀 v（肚皮不断向外膨胀的过程） expansion 膨胀 n par/para =&gt; 准备， par = pair 一对 =&gt; apparatus 仪器、设备、装置（辅助的作用） ap: 加强语气 + par: 设备需要人来 准备 - para + atus: 复合名词后缀 =&gt; disparate adj. 完全不同的，不能比较的 dis: 否定 + par: 一样，平等 + ate: 形容词后缀 path: 感情=pass 发音很类似 passion 激情表示一种情绪 =&gt; antipathy n. 反感 anti: 抗 + path: 感情=pass 发音很类似 passion 激情表示一种情绪 =&gt; sympath n. 同情 sym: 相同 same + path: 感情=pass 发音很类似 passion 激情表示一种情绪 ped: pad 板、平板 / 教育 =&gt; expedition 远征，探险 ex + ped + ition =&gt; encyclop(a)edia n. 百科全书(覆盖很全面，360度无死角) en: 使，让 + cycl: 圆圈 + ped + ia: 名词后缀 pens =&gt; spend 花费、花钱 v =&gt; expensive 昂贵的 ex + pens + ive 把钱花出去 =&gt; expense 花费 n =&gt; pension 抚恤金，补贴 pens + ion pet: 追求 compete 竞争 =&gt; impetus n. 动力（内在的一种追求，给了你内在的驱动力） im: 向内 + pet + us: 名词后缀 pl: 说, 满 complete =&gt; explore 探索 ex + pl + ore 向外说，告知你的过程，叫做探索 =&gt; deplete v. 大量减少 de: 向下 + pl: 满 complete + ete: 动词后缀 plic: 折叠 =&gt; complicated 错中复杂 com + plic + ated 一起交错在一起 =&gt; explicit 明确的，清晰的 ex + plic + it 把折叠的东西打开，不隐藏 por: 口，孔 =&gt; porous adj. 多孔的，渗透的 por + ous: 形容词后缀 port: 港口 =&gt; export 港口 ex: 向外 + port pos: 放置 =&gt; dispose vt. 处理；处置；安排 dis: 分开，散开 + pose =&gt; deposition n. 免职 de: 去掉、否定 + pos: 放置 + ition: 名词后缀 =&gt; deposit 沉淀物、存款（每个月的沉淀物，余款） de: 向下 + pos: 放置 + it: 名词后缀(小的意思) =&gt; expose 暴露（把 姿势/造型 展现出来） =&gt; exposure 暴露、被报道 ex + pos: 放 =&gt; 姿势 + ure: 名词后缀 pre / pro 往前，前面 =&gt; history 史前 =&gt; president 坐在最前面的人（校长、主席、总统、董事长、帮主） =&gt; predict 预言 （pre 往前 dict 说） prec /preci: 价值 price =&gt; appreciate v. 感激，感谢（你说的东西有价值，值得感谢） ap: 加强语气 + preci + ate: 动词后缀 =&gt; deprecate v. 反对 de: 否定 + prec + ate: 动词后缀 =&gt; precious v. 宝贵 preci + ous: 形容词后缀 s 单词 soup 汤（喝汤的声音） 相声词 sorb 吸进去: 喝汤的动作 b和p 声音相似 absorb 吸引（用力吸进去） sat, sati, satis: 满足 satisfy =&gt; insatiable adj. 贪心的，无法满足的 in: 否定 + sati: 满足 + able: 形容词后缀 sc =&gt; c = sc 雕刻的意思 =&gt; caver 雕刻 =&gt; scale 刻度、鱼鳞、去掉鱼鳞 =&gt; scandal 丑闻（挖到了缺点） scar 疤痕（缺陷） + and + al 合成结尾 =&gt; scarf 围巾（脖子上雕刻了一个东西） sc + arf =&gt; scoop 铲子、勺子、挖新闻 sc: 雕刻，在土里，就是铲子；在媒体，就是挖新闻 + oop =&gt; sculpture 雕刻、雕像 sc + ul + pt + ure 合成结尾（类似： 黄晓、黄明、黄晓明） =&gt; score 分数、得到分数 sc + ore sign: 迹象 =&gt; signify v. 意味，预示 sign + ify: 动词后缀 sn =&gt; 势力 =&gt; snoopy 史努比，狗！ 像狗一样势力、爱探听的、爱管闲事的、讥讽和嘲笑 =&gt; snobbish 势力的，自命不凡的 =&gt; sneer 嘲笑、讥讽 =&gt; sniff 感冒了，用力吸气 =&gt; snore 打鼾 sn + ore sol =&gt; 单独 =&gt; solitary adj. 孤独的（一个人，肯定很孤独） sol: 单独 + itary: 形容词后缀 solv / solut =&gt; 解开 放松 溶解 =&gt; absolve vt. 免除、赦免、宣告…无罪 ab: 加强语气 + solve: 溶解，解开，解决 absolute adj. 绝对的；完全的: 不受任何限制 : absolve的过去分词形式 ab: 加强语气 + solut: 溶解，不受限制 son: 声音 =&gt; consonant 协调一致的: 所有的声音汇集到一起 con: 共同 + son: 声音 + ant: 形容词后缀 soph =&gt; 表示智慧 =&gt; sophisticated adj.诡辩的，久经世故的，精密的 soph: 表示智慧 + ist: 名词后缀 + ic: 形容词后缀 + ate: 动词后缀 + ed: 形容词后缀 =&gt; sophistication adj.复杂，老练 soph: 表示智慧 + ist: 名词后缀 + ic: 形容词后缀 + ation: 名词后缀 spit: v. 吐口水，吐痰 (发音和吐痰过程类似) spect: 看 =&gt; spy 间谍 =&gt; inspect 检查,监督 in + spect 往里看 =&gt; prospect 前景 pro + spect 往前看 =&gt; prophet 预言 pro + ph + et 往前说 =&gt; suspect 怀疑 su: b + spect 往下看 =&gt; expect v. 期望/预期 ex + spect 往外看（看出来） : ex 和 s 发音重合，就去掉 s expectation 期望/预期 n =&gt; retrospect v. 回顾 retro(往回) + spect st: 站住 stand =&gt; stable adj. 稳定的 st + able: 形容词后缀 str =&gt; 拉长、绷紧 =&gt; street 街道 =&gt; stream 小河; 溪 =&gt; struggle 挣扎 =&gt; strong 肌肉 =&gt; abstract 抽象的（拉长的事物，就变抽象了） simil: 类似，一样 =&gt; assimilate 同化、吸收 as: 加强语气 + simil: 类似，一样 + ate: 动词后缀 v=w=u 字母 v 字母 v =&gt; 像眼睛，引申为 看 view 看，风景 preview 提前看，预习 vac: 空 vaction 假期 =&gt; vacant adj. 空的 vac + ant: 形容词后缀 val / vail: 价值, 力量 （强壮、森林法则，才能留下来，就有价值的） =&gt; avail 利用 a: ad 加强语气 + vail =&gt; prevail 盛行、流行、占优势 pre: 提前 + vail =&gt; valid adj. 有效的；有根据的；合法的；正当的 val: 有价值的 + id: 形容词后缀 =&gt; equivalent adj. 相等的，相当的 equi: equ 相等的 + val + ent: 形容词后缀 ven: come 来 =&gt; avenue 大道 a: ad + ven + ue: 名词后缀 vis: 看 visit 拜访 television 电视 =&gt; invisible adj. 看不见的 in: 否定 + vis + ible: 形容词后缀 viv: 生命 =&gt; vivid adj. 生动的(有生命的，既有生机活力) viv + id: 形容词后缀 voc: 声音 voice =&gt; equivocate v. 模棱两可的说(相等的声音，两种很类似，不知道选什么) euqi: equ 相等的 + voc + ate: 动词后缀 void: 空 =&gt; avoid v. 避免（不接触，保持为空） a: 否定 + void =&gt; devoid adj. 缺乏的 de: 加强 + void w 字母 w 写到一般没水了，就是 v double u =&gt; w : 发音也类似 w =&gt; 水，波浪 =&gt; wave 波浪 =&gt; wine 红酒 u 字母 x 半元音 y 半元音 z 半元音 信息来源： https://www.bilibili.com/video/av66898367/ https://www.bilibili.com/video/av38381873 https://www.bilibili.com/video/av43458802 https://www.youtube.com/channel/UCJDRugwIaR0-tpHoyw2CoOg/videos 宾语从句 宾语从句： I don’t know what to do. I don’t know which one is the best. 象这种有what, which, that引导句子在整个句子, 充当宾语成分.那就是宾语从句. 主语：I 谓语：don’t know 宾语：what to do. 区别于 定语从句： I don’t know the man who is wearing a pair of glass. 象这中由who, which, that, when 引导的句子在整个句子中做定语成分就叫定语从句. 主语：i 谓语：don’t know 宾语：the man 定语：who is wearing a pair of glass.修饰the man. 定语从句 (限定范围) who-人/which-物 who-人 :定语从句形成过程 我认识那个在车里哭的人 (man作为主语，用who) 主： 我认识那个人 从： 那个人在车里哭 合： 我认识那个人 那个人在车里哭 I know the man the man is crying in the car. （the man is crying in the car, man是主语， who不可以省略） I know the man who is crying in the car. 我认识那个你喜欢的男孩 (主语用who 宾语用whom, 不过现在 主格和宾格 没严格了) 主： 我认识那个男孩 从： 你喜欢的男孩 合： 我认识那个男孩 你喜欢的男孩 I know the boy you like the boy. （you like the boy, boy不是主语，who/whom可以省略） I know the boy who/whom you like. I know the boy you like. 我认识那个喜欢你的男孩 主： 我认识那个男孩 从： 喜欢你的男孩 合： 我认识那个男孩 喜欢你的男孩 I know the boy the boy like you. （the boy like you, boy不是主语，who/whom可以省略） I know the boy who like you. which-物 :定语从句形成过程 which 我不喜欢没有图片的书 主： 我不喜欢书 从： 书没有图片 合： 我不喜欢书 书没有图片 I don’t like books books don’t have pictures. I don’t books which don’t have pictures. in which = where 我特别讨厌我遇见他的那个城市 (in 是本来就有，所以才有 in which=where, where 是一个偷懒的行为) 主： 我特别讨厌这个城市 从： 我遇见他的那个城市 合： 我特别讨厌这个城市 我遇见他的那个城市 I really hate the city In the city I met him. I really hate the city in which (in which=where) I met him. I really hate the city where I met him. on which = where 我还记得你喜欢的那个城市 主： 我还记得那个城市 从： 你喜欢的那个城市 合： 我还记得那个城市 你喜欢的那个城市 I still remember the city you like the city. I still remeber the city which you like. 我特别讨厌我遇见他的那张床 (on 是本来就有，所以才有 on which=where, where 是一个偷懒的行为) 主： 我特别讨厌这那张床 从： 我遇见他的那张床 合： 我特别讨厌那张床 我遇见他的那张床 I really hate the bed On the bed I met him. I really hate the bed on which (on which=where) I met him. I really hate the bed where I met him. on which = when 我都忘记了你在那个日子来的 (on 是本来就有，所以才有 on which=when, when 是一个偷懒的行为) 主： 我都忘记了日子 从： 你在那个日子来的 合： 我都忘记了日子 你在那个日子来的 I have forgeten the day you came on the day. I have forgeten the day on which (on which=when) you came. I have forgeted the day when you came. which 这是一本我正在找的书 （介词不提前，主要是 for和looking关系更紧密一点，are looking for 作为谓语） 主： 这是一本书 从： 我正在找的书 合： 这是一本书 我正在找的书 This is the book I am looking for the book. This is the book which I am looking for. which’s = whose, who’s = whose 我有一条蓝色眼睛的小狗 (which’s = whose, who’s = whose) 主： 我有一条小狗 从： 小狗的颜色是蓝色的 合： 我有一条小狗 小狗的颜色是蓝色的 I have a dog a dog`s eyes are blue. I hava a dog which’s eyes are blue. (当然没有 which’s 这种写法) I hava a dog whose eyes are blue. as 像 for which = because of which = why 我不理解他离开我的原因 (for which = because of which = why) 主： 我不理解这个原因 从： 他离开我的原因 合： 我不理解这个原因 他离开我的原因 I don’t understand the reason he left me for/because of the reason. I don’t understand the reason for which/because of which he left me. I don’t understand the reason why he left me. 非限定 定语从句（补充说明） - 插入语 I like my father, who is good to me. He left without bye bye, which made me sad. I’m from China, which is my home. That 偷懒行为 (which/who = that) which = that where = (in/on) + which 所以: where != that (而 in that 因为; 原因是;) I’m from China, which is my home. =&gt; I’m from China, and that is my home. （两个句子连接，需要连接词，不然就变成2个句子了） 必须用 that 有强调作用 all, everything, anything, nothing, little, much, any, each, no, some, few, the only, the very, the —est, the —th. You are the most beautiful girl that I have ever seen. –&gt; 特例（严谨性） You are not the only one who understands contract.（用who主要是想说这是人，而that(不合适)因为它还可以表示物） I know the man (who is) smiling in the car = I know the man smiling in the car. 反问句 宾语从句的反问： 如果前面是肯定，反问就否定； 如果前面是否定，反问就肯定。 I never thought that he would come for the dinner party, would he? 主语是我(我肯定是认同自己的)，所以肯定不会反问自己，而是别人 She never thought we were wrong, did she? 主语是she，那么是可以反问的 介词（preposition 简写prep.） 又称作前置词，表示名词、代词等与句中其它词的关系，在句中不能单独作句子成分。 介词可以分为: 时间介词、地点介词、方式介词、原因介词、数量介词和其他介词。 简单介词 in，on，with，by，for，at，about，under，of，to等。 (to为介词，意为“习惯(做)……”，后接名词，代词或动名词形式) 合成介词 into，within，throughout，inside，outside，without等 短语介词 一个或两个简单介词和一个或几个其他词类构成一个短语，作用相当于一个介词，这就叫做短语介词。这类介词的末尾总是一个简单介词。 according to，because of，by means of，in addit 常用介词 in: 在…里面、包含在内 in time 及时。指没有迟到,时间还充裕(例如：在7点之前来) in the morning/at noon 在上午/在晚上 call in + sth (拜访某地) on: 接触、长在某给地方、传播、进入某种状态、在…上面 on time 准点(例如：在7点踩点到) on a friday morning 指定的具体时间点（具体化了） call on + sb (on 接触，主要是加人，拜访某人) go on 继续（一个接一个 - 接触） on holiday 进行假期的状态 one on one 一对一（例如：家教） depend on 依靠 Don’t be too hard on me. 别对我太苛刻（上对下的压力，接触） She turned me on. 她让我来电、很心动 off: 脱离、断开 She turned me off. 她让我断电、很恶心 offspring 春天冒出、弹出新芽（出生、脱离母体） - 子孙后代 off-road 越野的（脱离道路） Lay off 下岗（把你放倒） Knock off 下班（敲钟打卡） break off 打断 call off 取消 carry off 带走 give off 脱离本地，发出（太阳发出光芒） show off 炫耀（拿出来展示） pay off 还清、还完（完全脱离） offbeat 脱离节奏 =&gt; 指脱离正常的规律的人or事 奇葩、奇闻趣事 above: 在…上面(更多表示没有接触) under: 在…下面 in front of: 在…前面 behind: 在…后面 beside: 在…旁边(或附近) between: 在…中间 toward: 趋向于(一个跨越的过程) Life is full of ups and downs, yet the tide(潮流) is unable to return. Ask not what can be done for you, but what can be done by you. To have a government that is of people, for people, by people. 量词 可数和不可数 数量的本质，一切皆不可数 单位相对固定 a cup of coffee 缩写 a coffee (常用，所以可以缩写) a car、a person、 同位语从句 句子 + that/, + 句子（两个完全独立的句子， 后面的句子用来 解释 前面的句子） 同位语从句 (两句话，隐藏的并列句) She hates the idea that we should abandon her. 他很讨厌这个观点，即我们要抛弃她 He, my brother, is a superstar. （他，即我的哥哥，是个明星。my brother 就是he的同位语，两者指同一个对象，只是同位语的含义更具体。） Tom, my brother, is coming. Tom 我哥马上来了 同位语和定语从句的区别： 定语从句 (一句话，修饰宾语) She hates the idea that you told her. 句子 + that + 句子（两个完全独立的句子， 后面的句子用来 限定（画了一个范围）前面的 the idea） 虚拟句 (虚-假的，拟-假设；不可能发生的事情 or 和假设相反的；用来加强语气，表达强烈的情绪) 主将从现：(本来应该都是will，但是为了让句子逻辑的先后关系更加通畅，所以 rains 现在时更符合！) if it rains tomorrow, I will pick you up.（不是虚拟，因为有可能成立！） – 对现在的虚拟 本应该是现在 I am you, were比was显得更离谱，但是为了突显假设，用错误的方式来表达一种更强烈的语气-强化语气-夸张手法 如果我是你，我就弄死他！ If I were you, I would kill him. 如果我是个女的，我就嫁给他。 If I were a girl, I would marry him.(虚拟写错的话，就更好理解：我不是要去做手术，而是一种仰慕之情。) If I am a girl, I would marry him.(所以一切可能发生的事情，必然发生or已经发生) – 对过去的虚拟 如果你昨天（就已经）告诉我，我昨天就（已经会）来了。 If you told me yesterday, I would came.（看单词yesterday是个时间点） If you had told me yesterday, I would have come.（和中文逻辑一样，相对于今天而来，是一个时间段，从昨天到今天，已经假设完成的状态） – 对将来的虚拟 如果明天地球炸了，我也要和你在一起。（be to do 将会怎么做） If the earth were to explode tomorrow, I would be with you. – 杂交, 混和 mix up 如果你当时说爱我，那现在我就是你的人了。 前面对过去的虚拟，表示已经完成 后面是将来的虚拟 If you had said it, I would be yours now. – 简化语句 (倒装句–用于强调句子) If you had told me. 简化语句，把重要的内容提前 Had you told me. If I were you Were I you. – 心愿 It is time that we made greater efforts at work. It is high time — It is about time — – 建议 I suggest that you go home now.（平等的建议， should 是一般都省略） I order that you should go home now.（命令是的建议， should 在语气上加强来语气） – 天然虚拟 If only 如果。。。就好了 If only I were you. Would rather 宁愿 I would rather I hadn`t made Alibaba. As if 貌似（看起来好像是，但其实不是的） He talks as if he knew everything. Lest 以免 Take the umbrella, lest you would get wet.(记得拿伞，以免打湿；已经带伞了，还担心打湿吗？) But for 若非, 若不是 But for you money, we would have lost. It is time that 是时候该干嘛了 It is time that we went to bed. （是时候该去睡觉了，但是我没去） Wish 祝福（超越现实： 例如，祝你长命百岁） I wish I could fly. I wish someone had told me all this when I was 13.(真希望我在13岁就有人告诉我这一切) 名言名句 Don`t lecture me! Don`t judge me! 主语从句 - 头重脚轻（基本上很少用） 主语从句 That you live her is a lie. 定语从句 =&gt; It is a lie （that 可省略…） you live her. 状语从句 状语从句： I don’t know she is my english teacher when i see her at first time. 我第一眼见到她的时候,不知道她是我的英语老师. 象这样以when引导的句子在整个句子中充当状语成分的就是状语从句. 主语：I 谓语：don’t know 宾语：she is my english teacher. 状语：when 引导的句子. 机场口语 一个没生活和视野的人，谈不上生活的质量！【不是事业】 谈到这个，我们就从英语开始，因为这才是打开视野的一种有趣方式。 你想去什么什么国家，你想去浪漫的土耳其？富得流油的沙特？还是放荡不羁爱自由的美国？ 机场场景 Can you give me a booklet? 你能给我个小册子吗？ I can`t find my baggage. 我找不到我的行李了 Where can I apply for lost things? 我可以在哪里申请寻物启事？ Where`s the bus stop? 公交站在哪里？ This is my hotel address. 这是我宾馆的位置。 This is shortcut. 这是条捷径 You can go there by bus. 你可以坐公交去这里 It`s very near. 很近的哦 Can you show me the way on the map? 你可以在地图上给我标注下吗？ You exceeded the speed limit. 你超速了 You are driving too fast. 你开的太快了 Diving license please. 请出示你的驾驶证 Do you hava a map of this area? 你们有这个地方的地图吗？ Where can i find? * How fat is it? * How do I get there? 我该怎么到那里呢？ I`ve run out of petrol 我没油拉！ May I use you phone? 我可以用用你的手机吗？ Can you send a mechanic? 你们能派过来一个修理师傅吗？ How would you like to travel? 你想哪种方式去旅行呢？ Can you rent a car there? 你能在那租赁一辆车吗？ I`m only carrying my hand luggage 我只带了我的行李箱 The flight has been canceled because of the storm. 由于暴风雪，航班已经取消了。 What`s weather like? 天气怎么样？ What about getting a drink together? 一起喝一杯怎么样？ I have lost my luggage 我把我的行李弄丢了 Describe your luggage please? 请描述一下你的行李 Would you call a cab? 你能叫个出租车吗？ Where do you wish to go? 你想到哪去？ Where does the train leave from? 那列火车从哪里出发的？ I hope we will be on time. 我希望我们能按时到达 Where will you stay? 你将会呆在哪里？ What`s the purpose of your visit? 你此次路行的目的是什么？ Can you spark our language? 你会说我们的语言吗？ What`s in this box? 这个箱子里面有什么？ 世界各国中英文国名对照表 英文 简称 中文 Afghanistan AF 阿富汗 Aland Islands AX 奥兰群岛 Albania AL 阿尔巴尼亚 Algeria DZ 阿尔及利亚 American Samoa AS 美属萨摩亚 Andorra AD 安道尔 Angola AO 安哥拉 Anguilla AI 安圭拉 Antigua and Barbuda AG 安提瓜和巴布达 Argentina AR 阿根廷 Armenia AM 亚美尼亚 Aruba AW 阿鲁巴 Australia AU 澳大利亚 Austria AT 奥地利 Azerbaijan AZ 阿塞拜疆 Bangladesh BD 孟加拉 Bahrain BH 巴林 Bahamas BS 巴哈马 Barbados BB 巴巴多斯 Belarus BY 白俄罗斯 Belgium BE 比利时 Belize BZ 伯利兹 Benin BJ 贝宁 Bermuda BM 百慕大 Bhutan BT 不丹 Bolivia BO 玻利维亚 Bosnia and Herzegovina BA 波斯尼亚和黑塞哥维那 Botswana BW 博茨瓦纳 Bouvet Island BV 布维岛 Brazil BR 巴西 Brunei BN 文莱 Bulgaria BG 保加利亚 Burkina Faso BF 布基纳法索 Burundi BI 布隆迪 Cambodia KH 柬埔寨 Cameroon CM 喀麦隆 Canada CA 加拿大 Cape Verde CV 佛得角 Central African Republic CF 中非 Chad TD 乍得 Chile CL 智利 Christmas Islands CX 圣诞岛 Cocos (keeling) Islands CC 科科斯（基林）群岛 Colombia CO 哥伦比亚 Comoros KM 科摩罗 Congo (Congo-Kinshasa) CD 刚果（金） Congo CG 刚果 Cook Islands CK 库克群岛 Costa Rica CR 哥斯达黎加 Cote D’Ivoire CI 科特迪瓦 China CN 中国 Croatia HR 克罗地亚 Cuba CU 古巴 Czech CZ 捷克 Cyprus CY 塞浦路斯 Denmark DK 丹麦 Djibouti DJ 吉布提 Dominica DM 多米尼加 East Timor 东帝汶 Ecuador EC 厄瓜多尔 Egypt EG 埃及 Equatorial Guinea GQ 赤道几内亚 Eritrea ER 厄立特里亚 Estonia EE 爱沙尼亚 Ethiopia ET 埃塞俄比亚 Faroe Islands FO 法罗群岛 Fiji FJ 斐济 Finland FI 芬兰 France FR 法国 MetropolitanFrance FX 法国大都会 French Guiana GF 法属圭亚那 French Polynesia PF 法属波利尼西亚 Gabon GA 加蓬 Gambia GM 冈比亚 Georgia GE 格鲁吉亚 Germany DE 德国 Ghana GH 加纳 Gibraltar GI 直布罗陀 Greece GR 希腊 Grenada GD 格林纳达 Guadeloupe GP 瓜德罗普岛 Guam GU 关岛 Guatemala GT 危地马拉 Guernsey GG 根西岛 Guinea-Bissau GW 几内亚比绍 Guinea GN 几内亚 Guyana GY 圭亚那 Haiti HT 海地 Honduras HN 洪都拉斯 Hungary HU 匈牙利 Iceland IS 冰岛 India IN 印度 Indonesia ID 印度尼西亚 Iran IR 伊朗 Iraq IQ 伊拉克 Ireland IE 爱尔兰 Isle of Man IM 马恩岛 Israel IL 以色列 Italy IT 意大利 Jamaica JM 牙买加 Japan JP 日本 Jersey JE 泽西岛 Jordan JO 约旦 Kazakhstan KZ 哈萨克斯坦 Kenya KE 肯尼亚 Kiribati KI 基里巴斯 Korea (South) KR 韩国 Korea (North) KD 朝鲜 Kuwait KW 科威特 Kyrgyzstan KG 吉尔吉斯斯坦 Laos LO 老挝 Latvia LV 拉脱维亚 Lebanon LB 黎巴嫩 Lesotho LS 莱索托 Liberia LR 利比里亚 Libya LY 利比亚 Liechtenstein LI 列支敦士登 Lithuania LT 立陶宛 Luxembourg LU 卢森堡 Macedonia MK 马其顿 Malawi MW 马拉维 Malaysia MY 马来西亚 Madagascar MG 马达加斯加 Maldives MV 马尔代夫 Mali ML 马里 Malta MT 马耳他 Marshall Islands MH 马绍尔群岛 Martinique MQ 马提尼克岛 Mauritania MR 毛里塔尼亚 Mauritius MU 毛里求斯 Mayotte YT 马约特 Mexico MX 墨西哥 Micronesia MF 密克罗尼西亚 Moldova MD 摩尔多瓦 Monaco MC 摩纳哥 Mongolia MN 蒙古 Montenegro ME 黑山 Montserrat MS 蒙特塞拉特 Morocco MA 摩洛哥 Mozambique MZ 莫桑比克 Myanmar MM 缅甸 Namibia NA 纳米比亚 Nauru NR 瑙鲁 Nepal NP 尼泊尔 Netherlands NL 荷兰 New Caledonia NC 新喀里多尼亚 New Zealand NZ 新西兰 Nicaragua NI 尼加拉瓜 Niger NE 尼日尔 Nigeria NG 尼日利亚 Niue NU 纽埃 Norfolk Island NF 诺福克岛 Norway NO 挪威 Oman OM 阿曼 Pakistan PK 巴基斯坦 Palau PW 帕劳 Palestine PS 巴勒斯坦 Panama PA 巴拿马 Papua New Guinea PG 巴布亚新几内亚 Peru PE 秘鲁 Philippines PH 菲律宾 Pitcairn Islands PN 皮特凯恩群岛 Poland PL 波兰 Portugal PT 葡萄牙 Puerto Rico PR 波多黎各 Qatar QA 卡塔尔 Reunion RE 留尼汪岛 Romania RO 罗马尼亚 Rwanda RW 卢旺达 Russian Federation RU 俄罗斯联邦 Saint Helena SH 圣赫勒拿 Saint Kitts-Nevis KN 圣基茨和尼维斯 Saint Lucia LC 圣卢西亚 Saint Vincent and the Grenadines VG 圣文森特和格林纳丁斯 El Salvador SV 萨尔瓦多 Samoa WS 萨摩亚 San Marino SM 圣马力诺 Sao Tome and Principe ST 圣多美和普林西比 Saudi Arabia SA 沙特阿拉伯 Senegal SN 塞内加尔 Seychelles SC 塞舌尔 Sierra Leone SL 塞拉利昂 Singapore SG 新加坡 Serbia RS 塞尔维亚 Slovakia SK 斯洛伐克 Slovenia SI 斯洛文尼亚 Solomon Islands SB 所罗门群岛 Somalia SO 索马里 South Africa ZA 南非 Spain ES 西班牙 Sri Lanka LK 斯里兰卡 Sudan SD 苏丹 Suriname SR 苏里南 Swaziland SZ 斯威士兰 Sweden SE 瑞典 Switzerland CH 瑞士 Syria SY 叙利亚 Tajikistan TJ 塔吉克斯坦 Tanzania TZ 坦桑尼亚 Thailand TH 泰国 Trinidad and Tobago TT 特立尼达和多巴哥 Timor-Leste TL 东帝汶 Togo TG 多哥 Tokelau TK 托克劳 Tonga TO 汤加 Tunisia TN 突尼斯 Turkey TR 土耳其 Turkmenistan TM 土库曼斯坦 Tuvalu TV 图瓦卢 Uganda UG 乌干达 Ukraine UA 乌克兰 United Arab Emirates AE 阿拉伯联合酋长国 United Kingdom UK 英国 United States US 美国 Uruguay UY 乌拉圭 Uzbekistan UZ 乌兹别克斯坦 Vanuatu VN 瓦努阿图 Vatican City VA 梵蒂冈 Venezuela VE 委内瑞拉 Vietnam VN 越南 Wallis and Futuna WF 瓦利斯群岛和富图纳群岛 Western Sahara EH 西撒哈拉 Yemen YE 也门 Yugoslavia YU 南斯拉夫 Zambia ZM 赞比亚 Zimbabwe ZW 津巴布韦 https://baike.baidu.com/item/中英文国家对照表/341490 日常口语 陈冠希 is A Native Speaker 母语者 His native language is English. kind of lost soul 迷茫的灵魂 我现在很迷茫，我不知道该做什么 I feel kind of lost/I’m a little bit lost. I dunno what to do. 我们现在好像迷路了，我不知道向哪里走。 We’re kind of lost right now, I dunno where we’re going. 我生活在自己的世界里 I’m kind of in my own world. I just kind of + Verb/谓语/宾语 我就是不太想去 I just kind of don’t want to go. 我看这件事情感觉有点不对劲 I just kind of get a bad feeling about this. 我就是知道 I just kind of knew. Quite Honestly 说实话 Quite Honestly, I don’t really like him. Quite Honestly, this was a terrible idea. This was Quite Honestly the worst movie I’ve ever seen. stay away from 远离 你应该远离他 You should stay away from him. 远离这里 Stay away from there! as much as possible 尽可能多的 如果你想要减肥，你应该尽可能多的避开不健康的食物 If you want to lost weight, you should avoid unhealthy food as much as possible. feel like 感觉（是/像） I feel like an outsider. 我感觉像一个外人 I feel like this is a bad/terrible idea. 我感觉这是一个坏/糟糕的主意 I feel like I’m getting sick. I feel like you don’t trust me. chill/hang out - spend time(正式场合) 在家呆着什么都不干 I wanna chill with my friends. I’m gonna hang out with my friends. I’m just chilling at home right now. I’m just hanging at home. It could be through 通过某种渠道 也许是通过搜索引擎 It could be through the search engine. It’s not my thing 这不是我的东西/菜 指你对某事物、不感兴趣 如果想指人的话，可以说： he’s/she’s not my type. dark horse 黑马 black sheep 败家子，和家人关系处理不太好 Phrasal verbs 动词短语 It’s super common. 这是特别常用的 Why you gotta bother me, man? 你为什么要到扰我呢？兄弟 信息涞源： https://www.youtube.com/watch?v=rRdRcx40Kpw https://www.youtube.com/watch?v=7hFpPyU_74A"},{"path":"/about/index.html","content":"霰雪纷其无垠兮，云霏霏而承宇 📃简介 一个出生于00年代的IT小青年 喜欢折腾，折腾黑苹果，有空搞搞 DIY，写写小脚本，个人偏向物联网方向，什么app都要上一点无线通讯才行。 目前就职于一家小小的公司，职位：硬件助理工程师。 业余画点电路板，用STM32做些程序固件，有时候还写一点脚本。 做过用 C 和 Python 的单片机程序，使用过STM32CUBEIDE开发过，正在学习Linux嵌入式相关的程序以及系统和驱动制作。曾做过与图像识别以及人体骨架识别等 AI 方面的程序。 对网络安全方面比较感兴趣，初识 nmap 工具。 关于博客：2020年3月份，偶然发现了一篇文章，使用 hexo + GitHub 搭建个人博客，激起了我很大的兴趣，几乎每天的闲暇时间都会用来优化博客，前前后后用了不少主题，这几年断断续续写博客，比较久远的文章找不回来了，后来又重新回来写，打算记录一下折腾笔记。 📱二维码 📫联系方式 可下方留言 Github : https://github.com/HP-L Gitee : https://gitee.com/HP-L Gitee主站 : https://hp-l.github.io Github副站 : https://hp-l.gitee.io"},{"title":"文档","path":"/archives/index.html","content":""},{"title":"分类","path":"/categories/index.html","content":""},{"title":"fontdest","path":"/fontdest/index.html","content":""},{"title":"friends","path":"/friends/index.html","content":"朋友们 stellar github 地址stellar wiki 地址小冰博客北辰の小栈简简kali’s blog杜老师说Colsrch国光xaoxuu浮生梦拾记 添加友链可以下方留言 1234567&#123;&quot;title&quot;: &quot;test&quot;,&quot;url&quot;: &quot;https://test.cn&quot;,&quot;avatar&quot;: &quot;https://test.png&quot;,&quot;screenshot&quot;: &quot;https://test64ea32a1115f1.png&quot;,&quot;description&quot;: &quot;&quot;&#125;"},{"title":"gallery","path":"/gallery/index.html","content":""},{"title":"友情链接","path":"/link/12345678.html","content":"主题github地址 小冰博客 木子の博客 简简 kali’s blog 杜老师说 黑石博客 果果小师弟 Colsrch Xu’s Blog Example Website 1 Example Website 2"},{"title":"友情链接","path":"/link/index copy.html","content":".links-content{ margin-top:1rem; } .link-navigation::after { content: \" \"; display: block; clear: both; } .card { width: 45%; font-size: 1rem; padding: 10px 20px; border-radius: 4px; transition-duration: 0.15s; margin-bottom: 1rem; display:flex; } .card:nth-child(odd) { float: left; } .card:nth-child(even) { float: right; } .card:hover { transform: scale(1.1); box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04); } .card a { border:none; } .card .ava { width: 3rem!important; height: 3rem!important; margin:0!important; margin-right: 1em!important; border-radius:4px; } .card .card-header { font-style: italic; overflow: hidden; width: 100%; } .card .card-header a { font-style: normal; color: #2bbc8a; font-weight: bold; text-decoration: none; } .card .card-header a:hover { color: #d480aa; text-decoration: none; } .card .card-header .info { font-style:normal; color:#a3a3a3; font-size:14px; min-width: 0; overflow: hidden; white-space: nowrap; } stellar github 地址 主题github地址 小冰博客 小冰博客 北辰の小栈 别让怯弱否定了自己，别让懒惰耽误了青春 简简 简言之"},{"title":"友情链接","path":"/link/index.html","content":"添加友链可以下方留言 .links-content{ margin-top:1rem; } .link-navigation::after { content: \" \"; display: block; clear: both; } .card { width: 45%; font-size: 1rem; padding: 10px 20px; border-radius: 4px; transition-duration: 0.15s; margin-bottom: 1rem; display:flex; } .card:nth-child(odd) { float: left; } .card:nth-child(even) { float: right; } .card:hover { transform: scale(1.1); box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04); } .card a { border:none; } .card .ava { width: 3rem!important; height: 3rem!important; margin:0!important; margin-right: 1em!important; border-radius:4px; } .card .card-header { font-style: italic; overflow: hidden; width: 100%; } .card .card-header a { font-style: normal; color: #2bbc8a; font-weight: bold; text-decoration: none; } .card .card-header a:hover { color: #d480aa; text-decoration: none; } .card .card-header .info { font-style:normal; color:#a3a3a3; font-size:14px; min-width: 0; overflow: hidden; white-space: nowrap; } stellar github 地址 主题github地址 stellar github 地址 主题地址 小冰博客 小冰博客 北辰の小栈 别让怯弱否定了自己，别让懒惰耽误了青春 简简 简言之 kali’s blog 遇见更好的自己 杜老师说 杜老师说 Colsrch 愿多年以后，我可以酌一杯清酒，烂醉如泥，梦中回到我们的曾经。"},{"title":"headimg","path":"/headimg/index.html","content":""},{"title":"timeline","path":"/timeline/index.html","content":""},{"title":"册","path":"/webrss/index.html","content":"相册集这个宇宙真不错呀Excel 转换为 Markdown 表格markdown工具小土刀 2.0上士闻道，勤而行之"},{"title":"tags","path":"/tags/index.html","content":""}]